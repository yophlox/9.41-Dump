#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ControlRig

#include "Basic.hpp"

#include "AnimationCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "MovieSceneTracks_structs.hpp"
#include "PropertyPath_structs.hpp"
#include "MovieScene_structs.hpp"


namespace SDK
{

// Enum ControlRig.ERigExecutionType
// NumValues: 0x0003
enum class ERigExecutionType : uint8
{
	Runtime                                  = 0,
	Editing                                  = 1,
	Max                                      = 2,
};

// Enum ControlRig.EControlRigOpCode
// NumValues: 0x0005
enum class EControlRigOpCode : uint8
{
	Done                                     = 0,
	Copy                                     = 1,
	Exec                                     = 2,
	Invalid                                  = 3,
	EControlRigOpCode_MAX                    = 4,
};

// Enum ControlRig.EBoneGetterSetterMode
// NumValues: 0x0003
enum class EBoneGetterSetterMode : uint8
{
	LocalSpace                               = 0,
	GlobalSpace                              = 1,
	Max                                      = 2,
};

// Enum ControlRig.ETransformGetterType
// NumValues: 0x0003
enum class ETransformGetterType : uint8
{
	Initial                                  = 0,
	Current                                  = 1,
	Max                                      = 2,
};

// Enum ControlRig.ETransformSpaceMode
// NumValues: 0x0005
enum class ETransformSpaceMode : uint8
{
	LocalSpace                               = 0,
	GlobalSpace                              = 1,
	BaseSpace                                = 2,
	BaseJoint                                = 3,
	Max                                      = 4,
};

// Enum ControlRig.EControlRigDrawHierarchyMode
// NumValues: 0x0002
enum class EControlRigDrawHierarchyMode : uint8
{
	Axes                                     = 0,
	Max                                      = 1,
};

// Enum ControlRig.EControlRigAnimEasingType
// NumValues: 0x0020
enum class EControlRigAnimEasingType : uint8
{
	Linear                                   = 0,
	QuadraticEaseIn                          = 1,
	QuadraticEaseOut                         = 2,
	QuadraticEaseInOut                       = 3,
	CubicEaseIn                              = 4,
	CubicEaseOut                             = 5,
	CubicEaseInOut                           = 6,
	QuarticEaseIn                            = 7,
	QuarticEaseOut                           = 8,
	QuarticEaseInOut                         = 9,
	QuinticEaseIn                            = 10,
	QuinticEaseOut                           = 11,
	QuinticEaseInOut                         = 12,
	SineEaseIn                               = 13,
	SineEaseOut                              = 14,
	SineEaseInOut                            = 15,
	CircularEaseIn                           = 16,
	CircularEaseOut                          = 17,
	CircularEaseInOut                        = 18,
	ExponentialEaseIn                        = 19,
	ExponentialEaseOut                       = 20,
	ExponentialEaseInOut                     = 21,
	ElasticEaseIn                            = 22,
	ElasticEaseOut                           = 23,
	ElasticEaseInOut                         = 24,
	BackEaseIn                               = 25,
	BackEaseOut                              = 26,
	BackEaseInOut                            = 27,
	BounceEaseIn                             = 28,
	BounceEaseOut                            = 29,
	BounceEaseInOut                          = 30,
	EControlRigAnimEasingType_MAX            = 31,
};

// Enum ControlRig.EControlRigRotationOrder
// NumValues: 0x0007
enum class EControlRigRotationOrder : uint8
{
	XYZ                                      = 0,
	XZY                                      = 1,
	YXZ                                      = 2,
	YZX                                      = 3,
	ZXY                                      = 4,
	ZYX                                      = 5,
	EControlRigRotationOrder_MAX             = 6,
};

// Enum ControlRig.ECRSimPointIntegrateType
// NumValues: 0x0003
enum class ECRSimPointIntegrateType : uint8
{
	Verlet                                   = 0,
	SemiExplicitEuler                        = 1,
	ECRSimPointIntegrateType_MAX             = 2,
};

// Enum ControlRig.ECRSimConstraintType
// NumValues: 0x0005
enum class ECRSimConstraintType : uint8
{
	Distance                                 = 0,
	DistanceFromA                            = 1,
	DistanceFromB                            = 2,
	Plane                                    = 3,
	ECRSimConstraintType_MAX                 = 4,
};

// Enum ControlRig.ECRSimPointForceType
// NumValues: 0x0002
enum class ECRSimPointForceType : uint8
{
	Direction                                = 0,
	ECRSimPointForceType_MAX                 = 1,
};

// Enum ControlRig.ECRSimSoftCollisionType
// NumValues: 0x0004
enum class ECRSimSoftCollisionType : uint8
{
	Plane                                    = 0,
	Sphere                                   = 1,
	Cone                                     = 2,
	ECRSimSoftCollisionType_MAX              = 3,
};

// Enum ControlRig.EUnitExecutionType
// NumValues: 0x0005
enum class EUnitExecutionType : uint8
{
	Always                                   = 0,
	InEditingTime                            = 1,
	Disable                                  = 2,
	Initialize                               = 3,
	Max                                      = 4,
};

// Enum ControlRig.EAimMode
// NumValues: 0x0003
enum class EAimMode : uint8
{
	AimAtTarget                              = 0,
	OrientToTarget                           = 1,
	MAX                                      = 2,
};

// Enum ControlRig.EApplyTransformMode
// NumValues: 0x0003
enum class EApplyTransformMode : uint8
{
	Override                                 = 0,
	Additive                                 = 1,
	Max                                      = 2,
};

// Enum ControlRig.ERigUnitDebugPointMode
// NumValues: 0x0003
enum class ERigUnitDebugPointMode : uint8
{
	Point                                    = 0,
	Vector                                   = 1,
	Max                                      = 2,
};

// Enum ControlRig.ERigUnitDebugTransformMode
// NumValues: 0x0004
enum class ERigUnitDebugTransformMode : uint8
{
	Point                                    = 0,
	Axes                                     = 1,
	Box                                      = 2,
	Max                                      = 3,
};

// Enum ControlRig.EControlRigCurveAlignment
// NumValues: 0x0003
enum class EControlRigCurveAlignment : uint8
{
	Front                                    = 0,
	Stretched                                = 1,
	EControlRigCurveAlignment_MAX            = 2,
};

// Enum ControlRig.EControlRigVectorKind
// NumValues: 0x0003
enum class EControlRigVectorKind : uint8
{
	Direction                                = 0,
	Location                                 = 1,
	EControlRigVectorKind_MAX                = 2,
};

// Enum ControlRig.EControlRigModifyBoneMode
// NumValues: 0x0005
enum class EControlRigModifyBoneMode : uint8
{
	OverrideLocal                            = 0,
	OverrideGlobal                           = 1,
	AdditiveLocal                            = 2,
	AdditiveGlobal                           = 3,
	Max                                      = 4,
};

// Enum ControlRig.EControlRigState
// NumValues: 0x0004
enum class EControlRigState : uint8
{
	Init                                     = 0,
	Update                                   = 1,
	Invalid                                  = 2,
	EControlRigState_MAX                     = 3,
};

// ScriptStruct ControlRig.RigUnit
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FRigUnit
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RigUnitName;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RigUnitStructName;                                 // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnitExecutionType                            ExecutionType;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit) == 0x000008, "Wrong alignment on FRigUnit");
static_assert(sizeof(FRigUnit) == 0x000020, "Wrong size on FRigUnit");
static_assert(offsetof(FRigUnit, RigUnitName) == 0x000008, "Member 'FRigUnit::RigUnitName' has a wrong offset!");
static_assert(offsetof(FRigUnit, RigUnitStructName) == 0x000010, "Member 'FRigUnit::RigUnitStructName' has a wrong offset!");
static_assert(offsetof(FRigUnit, ExecutionType) == 0x000018, "Member 'FRigUnit::ExecutionType' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_AnimBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_AnimBase) == 0x000008, "Wrong alignment on FRigUnit_AnimBase");
static_assert(sizeof(FRigUnit_AnimBase) == 0x000020, "Wrong size on FRigUnit_AnimBase");

// ScriptStruct ControlRig.RigUnit_AnimEvalRichCurve
// 0x00A8 (0x00C8 - 0x0020)
struct FRigUnit_AnimEvalRichCurve final : public FRigUnit_AnimBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0028(0x0088)(NativeAccessSpecifierPublic)
	float                                         SourceMinimum;                                     // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMaximum;                                     // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMinimum;                                     // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaximum;                                     // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AnimEvalRichCurve) == 0x000008, "Wrong alignment on FRigUnit_AnimEvalRichCurve");
static_assert(sizeof(FRigUnit_AnimEvalRichCurve) == 0x0000C8, "Wrong size on FRigUnit_AnimEvalRichCurve");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, Value) == 0x000020, "Member 'FRigUnit_AnimEvalRichCurve::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, Curve) == 0x000028, "Member 'FRigUnit_AnimEvalRichCurve::Curve' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, SourceMinimum) == 0x0000B0, "Member 'FRigUnit_AnimEvalRichCurve::SourceMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, SourceMaximum) == 0x0000B4, "Member 'FRigUnit_AnimEvalRichCurve::SourceMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, TargetMinimum) == 0x0000B8, "Member 'FRigUnit_AnimEvalRichCurve::TargetMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, TargetMaximum) == 0x0000BC, "Member 'FRigUnit_AnimEvalRichCurve::TargetMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEvalRichCurve, Result) == 0x0000C0, "Member 'FRigUnit_AnimEvalRichCurve::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SimBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_SimBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_SimBase) == 0x000008, "Wrong alignment on FRigUnit_SimBase");
static_assert(sizeof(FRigUnit_SimBase) == 0x000020, "Wrong size on FRigUnit_SimBase");

// ScriptStruct ControlRig.RigUnit_AccumulateFloatAdd
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_AccumulateFloatAdd final : public FRigUnit_SimBase
{
public:
	float                                         Increment;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialValue;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedValue;                                  // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateFloatAdd) == 0x000008, "Wrong alignment on FRigUnit_AccumulateFloatAdd");
static_assert(sizeof(FRigUnit_AccumulateFloatAdd) == 0x000038, "Wrong size on FRigUnit_AccumulateFloatAdd");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, Increment) == 0x000020, "Member 'FRigUnit_AccumulateFloatAdd::Increment' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, InitialValue) == 0x000024, "Member 'FRigUnit_AccumulateFloatAdd::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, bIntegrateDeltaTime) == 0x000028, "Member 'FRigUnit_AccumulateFloatAdd::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, Result) == 0x00002C, "Member 'FRigUnit_AccumulateFloatAdd::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatAdd, AccumulatedValue) == 0x000030, "Member 'FRigUnit_AccumulateFloatAdd::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.CRSimPointForce
// 0x0018 (0x0018 - 0x0000)
struct FCRSimPointForce final
{
public:
	ECRSimPointForceType                          ForceType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector;                                            // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Coefficient;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalize;                                        // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCRSimPointForce) == 0x000004, "Wrong alignment on FCRSimPointForce");
static_assert(sizeof(FCRSimPointForce) == 0x000018, "Wrong size on FCRSimPointForce");
static_assert(offsetof(FCRSimPointForce, ForceType) == 0x000000, "Member 'FCRSimPointForce::ForceType' has a wrong offset!");
static_assert(offsetof(FCRSimPointForce, Vector) == 0x000004, "Member 'FCRSimPointForce::Vector' has a wrong offset!");
static_assert(offsetof(FCRSimPointForce, Coefficient) == 0x000010, "Member 'FCRSimPointForce::Coefficient' has a wrong offset!");
static_assert(offsetof(FCRSimPointForce, bNormalize) == 0x000014, "Member 'FCRSimPointForce::bNormalize' has a wrong offset!");

// ScriptStruct ControlRig.ConstraintNodeData
// 0x00B0 (0x00B0 - 0x0000)
struct FConstraintNodeData final
{
public:
	struct FTransform                             RelativeParent;                                    // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FConstraintOffset                      ConstraintOffset;                                  // 0x0030(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LinkedNode;                                        // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransformConstraint>           Constraints;                                       // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConstraintNodeData) == 0x000010, "Wrong alignment on FConstraintNodeData");
static_assert(sizeof(FConstraintNodeData) == 0x0000B0, "Wrong size on FConstraintNodeData");
static_assert(offsetof(FConstraintNodeData, RelativeParent) == 0x000000, "Member 'FConstraintNodeData::RelativeParent' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, ConstraintOffset) == 0x000030, "Member 'FConstraintNodeData::ConstraintOffset' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, LinkedNode) == 0x000090, "Member 'FConstraintNodeData::LinkedNode' has a wrong offset!");
static_assert(offsetof(FConstraintNodeData, Constraints) == 0x000098, "Member 'FConstraintNodeData::Constraints' has a wrong offset!");

// ScriptStruct ControlRig.AnimationHierarchy
// 0x0010 (0x0088 - 0x0078)
struct FAnimationHierarchy final : public FNodeHierarchyWithUserData
{
public:
	TArray<struct FConstraintNodeData>            UserData;                                          // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationHierarchy) == 0x000008, "Wrong alignment on FAnimationHierarchy");
static_assert(sizeof(FAnimationHierarchy) == 0x000088, "Wrong size on FAnimationHierarchy");
static_assert(offsetof(FAnimationHierarchy, UserData) == 0x000078, "Member 'FAnimationHierarchy::UserData' has a wrong offset!");

// ScriptStruct ControlRig.RigBone
// 0x00C0 (0x00C0 - 0x0000)
struct FRigBone final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParentIndex;                                       // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitialTransform;                                  // 0x0020(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             GlobalTransform;                                   // 0x0050(0x0030)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x0080(0x0030)(Edit, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Dependents;                                        // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigBone) == 0x000010, "Wrong alignment on FRigBone");
static_assert(sizeof(FRigBone) == 0x0000C0, "Wrong size on FRigBone");
static_assert(offsetof(FRigBone, Name) == 0x000000, "Member 'FRigBone::Name' has a wrong offset!");
static_assert(offsetof(FRigBone, ParentName) == 0x000008, "Member 'FRigBone::ParentName' has a wrong offset!");
static_assert(offsetof(FRigBone, ParentIndex) == 0x000010, "Member 'FRigBone::ParentIndex' has a wrong offset!");
static_assert(offsetof(FRigBone, InitialTransform) == 0x000020, "Member 'FRigBone::InitialTransform' has a wrong offset!");
static_assert(offsetof(FRigBone, GlobalTransform) == 0x000050, "Member 'FRigBone::GlobalTransform' has a wrong offset!");
static_assert(offsetof(FRigBone, LocalTransform) == 0x000080, "Member 'FRigBone::LocalTransform' has a wrong offset!");
static_assert(offsetof(FRigBone, Dependents) == 0x0000B0, "Member 'FRigBone::Dependents' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_MathBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_MathBase) == 0x000008, "Wrong alignment on FRigUnit_MathBase");
static_assert(sizeof(FRigUnit_MathBase) == 0x000020, "Wrong size on FRigUnit_MathBase");

// ScriptStruct ControlRig.RigUnit_MathFloatBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_MathFloatBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathFloatBase) == 0x000008, "Wrong alignment on FRigUnit_MathFloatBase");
static_assert(sizeof(FRigUnit_MathFloatBase) == 0x000020, "Wrong size on FRigUnit_MathFloatBase");

// ScriptStruct ControlRig.RigUnit_MathFloatUnaryOp
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_MathFloatUnaryOp : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatUnaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathFloatUnaryOp");
static_assert(sizeof(FRigUnit_MathFloatUnaryOp) == 0x000028, "Wrong size on FRigUnit_MathFloatUnaryOp");
static_assert(offsetof(FRigUnit_MathFloatUnaryOp, Value) == 0x000020, "Member 'FRigUnit_MathFloatUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatUnaryOp, Result) == 0x000024, "Member 'FRigUnit_MathFloatUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatCos
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatCos final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatCos) == 0x000008, "Wrong alignment on FRigUnit_MathFloatCos");
static_assert(sizeof(FRigUnit_MathFloatCos) == 0x000028, "Wrong size on FRigUnit_MathFloatCos");

// ScriptStruct ControlRig.AnimNode_ControlRigBase
// 0x0068 (0x00C0 - 0x0058)
struct FAnimNode_ControlRigBase : public FAnimNode_CustomProperty
{
public:
	TArray<class FName>                           ControlRigNodeMapping;                             // 0x0058(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, uint16>                     CurveMappingUIDs;                                  // 0x0068(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UNodeMappingContainer>   NodeMappingContainer;                              // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FAnimNode_ControlRigBase) == 0x000008, "Wrong alignment on FAnimNode_ControlRigBase");
static_assert(sizeof(FAnimNode_ControlRigBase) == 0x0000C0, "Wrong size on FAnimNode_ControlRigBase");
static_assert(offsetof(FAnimNode_ControlRigBase, ControlRigNodeMapping) == 0x000058, "Member 'FAnimNode_ControlRigBase::ControlRigNodeMapping' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, CurveMappingUIDs) == 0x000068, "Member 'FAnimNode_ControlRigBase::CurveMappingUIDs' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRigBase, NodeMappingContainer) == 0x0000B8, "Member 'FAnimNode_ControlRigBase::NodeMappingContainer' has a wrong offset!");

// ScriptStruct ControlRig.AnimNode_ControlRig_ExternalSource
// 0x0008 (0x00C8 - 0x00C0)
struct FAnimNode_ControlRig_ExternalSource final : public FAnimNode_ControlRigBase
{
public:
	TWeakObjectPtr<class UControlRig>             ControlRig;                                        // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimNode_ControlRig_ExternalSource) == 0x000008, "Wrong alignment on FAnimNode_ControlRig_ExternalSource");
static_assert(sizeof(FAnimNode_ControlRig_ExternalSource) == 0x0000C8, "Wrong size on FAnimNode_ControlRig_ExternalSource");
static_assert(offsetof(FAnimNode_ControlRig_ExternalSource, ControlRig) == 0x0000C0, "Member 'FAnimNode_ControlRig_ExternalSource::ControlRig' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimBone_Target
// 0x0028 (0x0028 - 0x0000)
struct FRigUnit_AimBone_Target final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigVectorKind                         Kind;                                              // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Space;                                             // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimBone_Target) == 0x000004, "Wrong alignment on FRigUnit_AimBone_Target");
static_assert(sizeof(FRigUnit_AimBone_Target) == 0x000028, "Wrong size on FRigUnit_AimBone_Target");
static_assert(offsetof(FRigUnit_AimBone_Target, Weight) == 0x000000, "Member 'FRigUnit_AimBone_Target::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_Target, Axis) == 0x000004, "Member 'FRigUnit_AimBone_Target::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_Target, Target) == 0x000010, "Member 'FRigUnit_AimBone_Target::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_Target, Kind) == 0x00001C, "Member 'FRigUnit_AimBone_Target::Kind' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_Target, Space) == 0x000020, "Member 'FRigUnit_AimBone_Target::Space' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigExecuteContext
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FControlRigExecuteContext final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigExecuteContext) == 0x000008, "Wrong alignment on FControlRigExecuteContext");
static_assert(sizeof(FControlRigExecuteContext) == 0x000018, "Wrong size on FControlRigExecuteContext");

// ScriptStruct ControlRig.RigUnitMutable
// 0x0018 (0x0038 - 0x0020)
struct FRigUnitMutable : public FRigUnit
{
public:
	struct FControlRigExecuteContext              ExecuteContext;                                    // 0x0020(0x0018)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnitMutable) == 0x000008, "Wrong alignment on FRigUnitMutable");
static_assert(sizeof(FRigUnitMutable) == 0x000038, "Wrong size on FRigUnitMutable");
static_assert(offsetof(FRigUnitMutable, ExecuteContext) == 0x000020, "Member 'FRigUnitMutable::ExecuteContext' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_HighlevelBaseMutable
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_HighlevelBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_HighlevelBaseMutable) == 0x000008, "Wrong alignment on FRigUnit_HighlevelBaseMutable");
static_assert(sizeof(FRigUnit_HighlevelBaseMutable) == 0x000038, "Wrong size on FRigUnit_HighlevelBaseMutable");

// ScriptStruct ControlRig.RigUnit_AimBone_DebugSettings
// 0x0040 (0x0040 - 0x0000)
struct FRigUnit_AimBone_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AimBone_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_AimBone_DebugSettings");
static_assert(sizeof(FRigUnit_AimBone_DebugSettings) == 0x000040, "Wrong size on FRigUnit_AimBone_DebugSettings");
static_assert(offsetof(FRigUnit_AimBone_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_AimBone_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_AimBone_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone_DebugSettings, WorldOffset) == 0x000010, "Member 'FRigUnit_AimBone_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimBone
// 0x00C8 (0x0100 - 0x0038)
struct FRigUnit_AimBone final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   Bone;                                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_AimBone_Target                Primary;                                           // 0x0040(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_AimBone_Target                Secondary;                                         // 0x0068(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_AimBone_DebugSettings         DebugSettings;                                     // 0x00A0(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrimaryCachedSpaceName;                            // 0x00E4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryCachedSpaceIndex;                           // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondaryCachedSpaceName;                          // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryCachedSpaceIndex;                         // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AimBone) == 0x000010, "Wrong alignment on FRigUnit_AimBone");
static_assert(sizeof(FRigUnit_AimBone) == 0x000100, "Wrong size on FRigUnit_AimBone");
static_assert(offsetof(FRigUnit_AimBone, Bone) == 0x000038, "Member 'FRigUnit_AimBone::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, Primary) == 0x000040, "Member 'FRigUnit_AimBone::Primary' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, Secondary) == 0x000068, "Member 'FRigUnit_AimBone::Secondary' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, bPropagateToChildren) == 0x000090, "Member 'FRigUnit_AimBone::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, DebugSettings) == 0x0000A0, "Member 'FRigUnit_AimBone::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, BoneIndex) == 0x0000E0, "Member 'FRigUnit_AimBone::BoneIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, PrimaryCachedSpaceName) == 0x0000E4, "Member 'FRigUnit_AimBone::PrimaryCachedSpaceName' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, PrimaryCachedSpaceIndex) == 0x0000EC, "Member 'FRigUnit_AimBone::PrimaryCachedSpaceIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, SecondaryCachedSpaceName) == 0x0000F0, "Member 'FRigUnit_AimBone::SecondaryCachedSpaceName' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimBone, SecondaryCachedSpaceIndex) == 0x0000F8, "Member 'FRigUnit_AimBone::SecondaryCachedSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchy
// 0x0060 (0x0060 - 0x0000)
struct FRigHierarchy final
{
public:
	TArray<struct FRigBone>                       Bones;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      NameToIndexMapping;                                // 0x0010(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigHierarchy) == 0x000008, "Wrong alignment on FRigHierarchy");
static_assert(sizeof(FRigHierarchy) == 0x000060, "Wrong size on FRigHierarchy");
static_assert(offsetof(FRigHierarchy, Bones) == 0x000000, "Member 'FRigHierarchy::Bones' has a wrong offset!");
static_assert(offsetof(FRigHierarchy, NameToIndexMapping) == 0x000010, "Member 'FRigHierarchy::NameToIndexMapping' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchyContainer
// 0x00C0 (0x00C0 - 0x0000)
struct FRigHierarchyContainer final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigHierarchy                          BaseHierarchy;                                     // 0x0060(0x0060)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigHierarchyContainer) == 0x000008, "Wrong alignment on FRigHierarchyContainer");
static_assert(sizeof(FRigHierarchyContainer) == 0x0000C0, "Wrong size on FRigHierarchyContainer");
static_assert(offsetof(FRigHierarchyContainer, BaseHierarchy) == 0x000060, "Member 'FRigHierarchyContainer::BaseHierarchy' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_RandomVector
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_RandomVector final : public FRigUnit_MathBase
{
public:
	int32                                         Seed;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastResult;                                        // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSeed;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLeft;                                          // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_RandomVector) == 0x000008, "Wrong alignment on FRigUnit_RandomVector");
static_assert(sizeof(FRigUnit_RandomVector) == 0x000050, "Wrong size on FRigUnit_RandomVector");
static_assert(offsetof(FRigUnit_RandomVector, Seed) == 0x000020, "Member 'FRigUnit_RandomVector::Seed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, Minimum) == 0x000024, "Member 'FRigUnit_RandomVector::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, Maximum) == 0x000028, "Member 'FRigUnit_RandomVector::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, Duration) == 0x00002C, "Member 'FRigUnit_RandomVector::Duration' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, Result) == 0x000030, "Member 'FRigUnit_RandomVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, LastResult) == 0x00003C, "Member 'FRigUnit_RandomVector::LastResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, LastSeed) == 0x000048, "Member 'FRigUnit_RandomVector::LastSeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomVector, TimeLeft) == 0x00004C, "Member 'FRigUnit_RandomVector::TimeLeft' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_MathVectorBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathVectorBase) == 0x000008, "Wrong alignment on FRigUnit_MathVectorBase");
static_assert(sizeof(FRigUnit_MathVectorBase) == 0x000020, "Wrong size on FRigUnit_MathVectorBase");

// ScriptStruct ControlRig.RigUnit_MathVectorBinaryOp
// 0x0028 (0x0048 - 0x0020)
struct FRigUnit_MathVectorBinaryOp : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorBinaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathVectorBinaryOp");
static_assert(sizeof(FRigUnit_MathVectorBinaryOp) == 0x000048, "Wrong size on FRigUnit_MathVectorBinaryOp");
static_assert(offsetof(FRigUnit_MathVectorBinaryOp, A) == 0x000020, "Member 'FRigUnit_MathVectorBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBinaryOp, B) == 0x00002C, "Member 'FRigUnit_MathVectorBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBinaryOp, Result) == 0x000038, "Member 'FRigUnit_MathVectorBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CCDIK_RotationLimit
// 0x000C (0x000C - 0x0000)
struct FRigUnit_CCDIK_RotationLimit final
{
public:
	class FName                                   Bone;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limit;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CCDIK_RotationLimit) == 0x000004, "Wrong alignment on FRigUnit_CCDIK_RotationLimit");
static_assert(sizeof(FRigUnit_CCDIK_RotationLimit) == 0x00000C, "Wrong size on FRigUnit_CCDIK_RotationLimit");
static_assert(offsetof(FRigUnit_CCDIK_RotationLimit, Bone) == 0x000000, "Member 'FRigUnit_CCDIK_RotationLimit::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK_RotationLimit, Limit) == 0x000008, "Member 'FRigUnit_CCDIK_RotationLimit::Limit' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CCDIK
// 0x00B8 (0x00F0 - 0x0038)
struct FRigUnit_CCDIK final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectorBone;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EffectorTransform;                                 // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterations;                                     // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFromTail;                                    // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseRotationLimit;                                 // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_CCDIK_RotationLimit>   RotationLimits;                                    // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x4F];                                      // 0x00A1(0x004F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_CCDIK) == 0x000010, "Wrong alignment on FRigUnit_CCDIK");
static_assert(sizeof(FRigUnit_CCDIK) == 0x0000F0, "Wrong size on FRigUnit_CCDIK");
static_assert(offsetof(FRigUnit_CCDIK, StartBone) == 0x000038, "Member 'FRigUnit_CCDIK::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, EffectorBone) == 0x000040, "Member 'FRigUnit_CCDIK::EffectorBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, EffectorTransform) == 0x000050, "Member 'FRigUnit_CCDIK::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, Precision) == 0x000080, "Member 'FRigUnit_CCDIK::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, MaxIterations) == 0x000084, "Member 'FRigUnit_CCDIK::MaxIterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, bStartFromTail) == 0x000088, "Member 'FRigUnit_CCDIK::bStartFromTail' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, BaseRotationLimit) == 0x00008C, "Member 'FRigUnit_CCDIK::BaseRotationLimit' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, RotationLimits) == 0x000090, "Member 'FRigUnit_CCDIK::RotationLimits' has a wrong offset!");
static_assert(offsetof(FRigUnit_CCDIK, bPropagateToChildren) == 0x0000A0, "Member 'FRigUnit_CCDIK::bPropagateToChildren' has a wrong offset!");

// ScriptStruct ControlRig.AnimNode_ControlRig
// 0x0160 (0x0220 - 0x00C0)
struct FAnimNode_ControlRig final : public FAnimNode_ControlRigBase
{
public:
	struct FPoseLink                              Source;                                            // 0x00C0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UControlRig>                ControlRigClass;                                   // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UControlRig*                            ControlRig;                                        // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class FName>                InputMapping;                                      // 0x00E0(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, class FName>                OutputMapping;                                     // 0x0130(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0xA0];                                     // 0x0180(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ControlRig) == 0x000008, "Wrong alignment on FAnimNode_ControlRig");
static_assert(sizeof(FAnimNode_ControlRig) == 0x000220, "Wrong size on FAnimNode_ControlRig");
static_assert(offsetof(FAnimNode_ControlRig, Source) == 0x0000C0, "Member 'FAnimNode_ControlRig::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, ControlRigClass) == 0x0000D0, "Member 'FAnimNode_ControlRig::ControlRigClass' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, ControlRig) == 0x0000D8, "Member 'FAnimNode_ControlRig::ControlRig' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, InputMapping) == 0x0000E0, "Member 'FAnimNode_ControlRig::InputMapping' has a wrong offset!");
static_assert(offsetof(FAnimNode_ControlRig, OutputMapping) == 0x000130, "Member 'FAnimNode_ControlRig::OutputMapping' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_QuaternionToAxisAndAngle
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_QuaternionToAxisAndAngle final : public FRigUnit
{
public:
	struct FQuat                                  Argument;                                          // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_QuaternionToAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionToAxisAndAngle");
static_assert(sizeof(FRigUnit_QuaternionToAxisAndAngle) == 0x000040, "Wrong size on FRigUnit_QuaternionToAxisAndAngle");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Argument) == 0x000020, "Member 'FRigUnit_QuaternionToAxisAndAngle::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Axis) == 0x000030, "Member 'FRigUnit_QuaternionToAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAxisAndAngle, Angle) == 0x00003C, "Member 'FRigUnit_QuaternionToAxisAndAngle::Angle' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatSign
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatSign final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatSign) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSign");
static_assert(sizeof(FRigUnit_MathFloatSign) == 0x000028, "Wrong size on FRigUnit_MathFloatSign");

// ScriptStruct ControlRig.CRSimPoint
// 0x0028 (0x0028 - 0x0000)
struct FCRSimPoint final
{
public:
	float                                         Mass;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearDamping;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InheritMotion;                                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinearVelocity;                                    // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCRSimPoint) == 0x000004, "Wrong alignment on FCRSimPoint");
static_assert(sizeof(FCRSimPoint) == 0x000028, "Wrong size on FCRSimPoint");
static_assert(offsetof(FCRSimPoint, Mass) == 0x000000, "Member 'FCRSimPoint::Mass' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, Size) == 0x000004, "Member 'FCRSimPoint::Size' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, LinearDamping) == 0x000008, "Member 'FCRSimPoint::LinearDamping' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, InheritMotion) == 0x00000C, "Member 'FCRSimPoint::InheritMotion' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, Position) == 0x000010, "Member 'FCRSimPoint::Position' has a wrong offset!");
static_assert(offsetof(FCRSimPoint, LinearVelocity) == 0x00001C, "Member 'FCRSimPoint::LinearVelocity' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigBindingTemplate
// 0x0000 (0x00B0 - 0x00B0)
struct FControlRigBindingTemplate final : public FMovieSceneSpawnSectionTemplate
{
};
static_assert(alignof(FControlRigBindingTemplate) == 0x000008, "Wrong alignment on FControlRigBindingTemplate");
static_assert(sizeof(FControlRigBindingTemplate) == 0x0000B0, "Wrong size on FControlRigBindingTemplate");

// ScriptStruct ControlRig.ControlRigComponentInstanceData
// 0x0008 (0x0060 - 0x0058)
struct FControlRigComponentInstanceData final : public FActorComponentInstanceData
{
public:
	class UControlRig*                            AnimControlRig;                                    // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigComponentInstanceData) == 0x000008, "Wrong alignment on FControlRigComponentInstanceData");
static_assert(sizeof(FControlRigComponentInstanceData) == 0x000060, "Wrong size on FControlRigComponentInstanceData");
static_assert(offsetof(FControlRigComponentInstanceData, AnimControlRig) == 0x000058, "Member 'FControlRigComponentInstanceData::AnimControlRig' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigOperator
// 0x0078 (0x0078 - 0x0000)
struct FControlRigOperator final
{
public:
	EControlRigOpCode                             OpCode;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PropertyPath1;                                     // 0x0008(0x0010)(ZeroConstructor, Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyPath2;                                     // 0x0018(0x0010)(ZeroConstructor, Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCachedPropertyPath                    CachedPropertyPath1;                               // 0x0028(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FCachedPropertyPath                    CachedPropertyPath2;                               // 0x0050(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigOperator) == 0x000008, "Wrong alignment on FControlRigOperator");
static_assert(sizeof(FControlRigOperator) == 0x000078, "Wrong size on FControlRigOperator");
static_assert(offsetof(FControlRigOperator, OpCode) == 0x000000, "Member 'FControlRigOperator::OpCode' has a wrong offset!");
static_assert(offsetof(FControlRigOperator, PropertyPath1) == 0x000008, "Member 'FControlRigOperator::PropertyPath1' has a wrong offset!");
static_assert(offsetof(FControlRigOperator, PropertyPath2) == 0x000018, "Member 'FControlRigOperator::PropertyPath2' has a wrong offset!");
static_assert(offsetof(FControlRigOperator, CachedPropertyPath1) == 0x000028, "Member 'FControlRigOperator::CachedPropertyPath1' has a wrong offset!");
static_assert(offsetof(FControlRigOperator, CachedPropertyPath2) == 0x000050, "Member 'FControlRigOperator::CachedPropertyPath2' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMul
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_MathVectorMul final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorMul) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMul");
static_assert(sizeof(FRigUnit_MathVectorMul) == 0x000048, "Wrong size on FRigUnit_MathVectorMul");

// ScriptStruct ControlRig.RigUnit_AccumulateFloatLerp
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_AccumulateFloatLerp final : public FRigUnit_SimBase
{
public:
	float                                         TargetValue;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialValue;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedValue;                                  // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateFloatLerp) == 0x000008, "Wrong alignment on FRigUnit_AccumulateFloatLerp");
static_assert(sizeof(FRigUnit_AccumulateFloatLerp) == 0x000038, "Wrong size on FRigUnit_AccumulateFloatLerp");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, TargetValue) == 0x000020, "Member 'FRigUnit_AccumulateFloatLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, InitialValue) == 0x000024, "Member 'FRigUnit_AccumulateFloatLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, Blend) == 0x000028, "Member 'FRigUnit_AccumulateFloatLerp::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, bIntegrateDeltaTime) == 0x00002C, "Member 'FRigUnit_AccumulateFloatLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, Result) == 0x000030, "Member 'FRigUnit_AccumulateFloatLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatLerp, AccumulatedValue) == 0x000034, "Member 'FRigUnit_AccumulateFloatLerp::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.CRSimLinearSpring
// 0x0010 (0x0010 - 0x0000)
struct FCRSimLinearSpring final
{
public:
	int32                                         SubjectA;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubjectB;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Coefficient;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Equilibrium;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCRSimLinearSpring) == 0x000004, "Wrong alignment on FCRSimLinearSpring");
static_assert(sizeof(FCRSimLinearSpring) == 0x000010, "Wrong size on FCRSimLinearSpring");
static_assert(offsetof(FCRSimLinearSpring, SubjectA) == 0x000000, "Member 'FCRSimLinearSpring::SubjectA' has a wrong offset!");
static_assert(offsetof(FCRSimLinearSpring, SubjectB) == 0x000004, "Member 'FCRSimLinearSpring::SubjectB' has a wrong offset!");
static_assert(offsetof(FCRSimLinearSpring, Coefficient) == 0x000008, "Member 'FCRSimLinearSpring::Coefficient' has a wrong offset!");
static_assert(offsetof(FCRSimLinearSpring, Equilibrium) == 0x00000C, "Member 'FCRSimLinearSpring::Equilibrium' has a wrong offset!");

// ScriptStruct ControlRig.CRFourPointBezier
// 0x0030 (0x0030 - 0x0000)
struct FCRFourPointBezier final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                C;                                                 // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                D;                                                 // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCRFourPointBezier) == 0x000004, "Wrong alignment on FCRFourPointBezier");
static_assert(sizeof(FCRFourPointBezier) == 0x000030, "Wrong size on FCRFourPointBezier");
static_assert(offsetof(FCRFourPointBezier, A) == 0x000000, "Member 'FCRFourPointBezier::A' has a wrong offset!");
static_assert(offsetof(FCRFourPointBezier, B) == 0x00000C, "Member 'FCRFourPointBezier::B' has a wrong offset!");
static_assert(offsetof(FCRFourPointBezier, C) == 0x000018, "Member 'FCRFourPointBezier::C' has a wrong offset!");
static_assert(offsetof(FCRFourPointBezier, D) == 0x000024, "Member 'FCRFourPointBezier::D' has a wrong offset!");

// ScriptStruct ControlRig.CRSimSoftCollision
// 0x0050 (0x0050 - 0x0000)
struct FCRSimSoftCollision final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ECRSimSoftCollisionType                       ShapeType;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistance;                                   // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     FalloffType;                                       // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Coefficient;                                       // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInverted;                                         // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0xB];                                       // 0x0045(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCRSimSoftCollision) == 0x000010, "Wrong alignment on FCRSimSoftCollision");
static_assert(sizeof(FCRSimSoftCollision) == 0x000050, "Wrong size on FCRSimSoftCollision");
static_assert(offsetof(FCRSimSoftCollision, Transform) == 0x000000, "Member 'FCRSimSoftCollision::Transform' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, ShapeType) == 0x000030, "Member 'FCRSimSoftCollision::ShapeType' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, MinimumDistance) == 0x000034, "Member 'FCRSimSoftCollision::MinimumDistance' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, MaximumDistance) == 0x000038, "Member 'FCRSimSoftCollision::MaximumDistance' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, FalloffType) == 0x00003C, "Member 'FCRSimSoftCollision::FalloffType' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, Coefficient) == 0x000040, "Member 'FCRSimSoftCollision::Coefficient' has a wrong offset!");
static_assert(offsetof(FCRSimSoftCollision, bInverted) == 0x000044, "Member 'FCRSimSoftCollision::bInverted' has a wrong offset!");

// ScriptStruct ControlRig.CRSimContainer
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCRSimContainer
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeStep;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTime;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLeftForStep;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCRSimContainer) == 0x000008, "Wrong alignment on FCRSimContainer");
static_assert(sizeof(FCRSimContainer) == 0x000018, "Wrong size on FCRSimContainer");
static_assert(offsetof(FCRSimContainer, TimeStep) == 0x000008, "Member 'FCRSimContainer::TimeStep' has a wrong offset!");
static_assert(offsetof(FCRSimContainer, AccumulatedTime) == 0x00000C, "Member 'FCRSimContainer::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FCRSimContainer, TimeLeftForStep) == 0x000010, "Member 'FCRSimContainer::TimeLeftForStep' has a wrong offset!");

// ScriptStruct ControlRig.CRSimPointConstraint
// 0x0024 (0x0024 - 0x0000)
struct FCRSimPointConstraint final
{
public:
	ECRSimConstraintType                          Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubjectA;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SubjectB;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DataA;                                             // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DataB;                                             // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCRSimPointConstraint) == 0x000004, "Wrong alignment on FCRSimPointConstraint");
static_assert(sizeof(FCRSimPointConstraint) == 0x000024, "Wrong size on FCRSimPointConstraint");
static_assert(offsetof(FCRSimPointConstraint, Type) == 0x000000, "Member 'FCRSimPointConstraint::Type' has a wrong offset!");
static_assert(offsetof(FCRSimPointConstraint, SubjectA) == 0x000004, "Member 'FCRSimPointConstraint::SubjectA' has a wrong offset!");
static_assert(offsetof(FCRSimPointConstraint, SubjectB) == 0x000008, "Member 'FCRSimPointConstraint::SubjectB' has a wrong offset!");
static_assert(offsetof(FCRSimPointConstraint, DataA) == 0x00000C, "Member 'FCRSimPointConstraint::DataA' has a wrong offset!");
static_assert(offsetof(FCRSimPointConstraint, DataB) == 0x000018, "Member 'FCRSimPointConstraint::DataB' has a wrong offset!");

// ScriptStruct ControlRig.CRSimPointContainer
// 0x0060 (0x0078 - 0x0018)
struct FCRSimPointContainer final : public FCRSimContainer
{
public:
	TArray<struct FCRSimPoint>                    Points;                                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimLinearSpring>             Springs;                                           // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimPointForce>               Forces;                                            // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimSoftCollision>            CollisionVolumes;                                  // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimPointConstraint>          Constraints;                                       // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimPoint>                    PreviousStep;                                      // 0x0068(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FCRSimPointContainer) == 0x000008, "Wrong alignment on FCRSimPointContainer");
static_assert(sizeof(FCRSimPointContainer) == 0x000078, "Wrong size on FCRSimPointContainer");
static_assert(offsetof(FCRSimPointContainer, Points) == 0x000018, "Member 'FCRSimPointContainer::Points' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, Springs) == 0x000028, "Member 'FCRSimPointContainer::Springs' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, Forces) == 0x000038, "Member 'FCRSimPointContainer::Forces' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, CollisionVolumes) == 0x000048, "Member 'FCRSimPointContainer::CollisionVolumes' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, Constraints) == 0x000058, "Member 'FCRSimPointContainer::Constraints' has a wrong offset!");
static_assert(offsetof(FCRSimPointContainer, PreviousStep) == 0x000068, "Member 'FCRSimPointContainer::PreviousStep' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PointSimulation_BoneTarget
// 0x0014 (0x0014 - 0x0000)
struct FRigUnit_PointSimulation_BoneTarget final
{
public:
	class FName                                   Bone;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TranslationPoint;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryAimPoint;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryAimPoint;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PointSimulation_BoneTarget) == 0x000004, "Wrong alignment on FRigUnit_PointSimulation_BoneTarget");
static_assert(sizeof(FRigUnit_PointSimulation_BoneTarget) == 0x000014, "Wrong size on FRigUnit_PointSimulation_BoneTarget");
static_assert(offsetof(FRigUnit_PointSimulation_BoneTarget, Bone) == 0x000000, "Member 'FRigUnit_PointSimulation_BoneTarget::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_BoneTarget, TranslationPoint) == 0x000008, "Member 'FRigUnit_PointSimulation_BoneTarget::TranslationPoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_BoneTarget, PrimaryAimPoint) == 0x00000C, "Member 'FRigUnit_PointSimulation_BoneTarget::PrimaryAimPoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_BoneTarget, SecondaryAimPoint) == 0x000010, "Member 'FRigUnit_PointSimulation_BoneTarget::SecondaryAimPoint' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_PointSimulation_DebugSettings
// 0x0050 (0x0050 - 0x0000)
struct FRigUnit_PointSimulation_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionScale;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawPointsAsSpheres;                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PointSimulation_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_PointSimulation_DebugSettings");
static_assert(sizeof(FRigUnit_PointSimulation_DebugSettings) == 0x000050, "Wrong size on FRigUnit_PointSimulation_DebugSettings");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_PointSimulation_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_PointSimulation_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, CollisionScale) == 0x000008, "Member 'FRigUnit_PointSimulation_DebugSettings::CollisionScale' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, bDrawPointsAsSpheres) == 0x00000C, "Member 'FRigUnit_PointSimulation_DebugSettings::bDrawPointsAsSpheres' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, Color) == 0x000010, "Member 'FRigUnit_PointSimulation_DebugSettings::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation_DebugSettings, WorldOffset) == 0x000020, "Member 'FRigUnit_PointSimulation_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SimBaseMutable
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_SimBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_SimBaseMutable) == 0x000008, "Wrong alignment on FRigUnit_SimBaseMutable");
static_assert(sizeof(FRigUnit_SimBaseMutable) == 0x000038, "Wrong size on FRigUnit_SimBaseMutable");

// ScriptStruct ControlRig.RigUnit_PointSimulation
// 0x0198 (0x01D0 - 0x0038)
struct FRigUnit_PointSimulation final : public FRigUnit_SimBaseMutable
{
public:
	TArray<struct FCRSimPoint>                    Points;                                            // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimLinearSpring>             Links;                                             // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimPointForce>               Forces;                                            // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCRSimSoftCollision>            CollisionVolumes;                                  // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SimulatedStepsPerSecond;                           // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECRSimPointIntegrateType                      IntegratorType;                                    // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerletBlend;                                       // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnit_PointSimulation_BoneTarget> BoneTargets;                                       // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLimitLocalPosition;                               // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PrimaryAimAxis;                                    // 0x009C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAimAxis;                                  // 0x00A8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_PointSimulation_DebugSettings DebugSettings;                                     // 0x00C0(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCRFourPointBezier                     Bezier;                                            // 0x0110(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	struct FCRSimPointContainer                   Simulation;                                        // 0x0140(0x0078)(NativeAccessSpecifierPublic)
	TArray<int32>                                 BoneIndices;                                       // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PointSimulation) == 0x000010, "Wrong alignment on FRigUnit_PointSimulation");
static_assert(sizeof(FRigUnit_PointSimulation) == 0x0001D0, "Wrong size on FRigUnit_PointSimulation");
static_assert(offsetof(FRigUnit_PointSimulation, Points) == 0x000038, "Member 'FRigUnit_PointSimulation::Points' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, Links) == 0x000048, "Member 'FRigUnit_PointSimulation::Links' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, Forces) == 0x000058, "Member 'FRigUnit_PointSimulation::Forces' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, CollisionVolumes) == 0x000068, "Member 'FRigUnit_PointSimulation::CollisionVolumes' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, SimulatedStepsPerSecond) == 0x000078, "Member 'FRigUnit_PointSimulation::SimulatedStepsPerSecond' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, IntegratorType) == 0x00007C, "Member 'FRigUnit_PointSimulation::IntegratorType' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, VerletBlend) == 0x000080, "Member 'FRigUnit_PointSimulation::VerletBlend' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, BoneTargets) == 0x000088, "Member 'FRigUnit_PointSimulation::BoneTargets' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, bLimitLocalPosition) == 0x000098, "Member 'FRigUnit_PointSimulation::bLimitLocalPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, bPropagateToChildren) == 0x000099, "Member 'FRigUnit_PointSimulation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, PrimaryAimAxis) == 0x00009C, "Member 'FRigUnit_PointSimulation::PrimaryAimAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, SecondaryAimAxis) == 0x0000A8, "Member 'FRigUnit_PointSimulation::SecondaryAimAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, DebugSettings) == 0x0000C0, "Member 'FRigUnit_PointSimulation::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, Bezier) == 0x000110, "Member 'FRigUnit_PointSimulation::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, Simulation) == 0x000140, "Member 'FRigUnit_PointSimulation::Simulation' has a wrong offset!");
static_assert(offsetof(FRigUnit_PointSimulation, BoneIndices) == 0x0001B8, "Member 'FRigUnit_PointSimulation::BoneIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorCross
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_MathVectorCross final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorCross) == 0x000008, "Wrong alignment on FRigUnit_MathVectorCross");
static_assert(sizeof(FRigUnit_MathVectorCross) == 0x000048, "Wrong size on FRigUnit_MathVectorCross");

// ScriptStruct ControlRig.ControlRigSequenceObjectReference
// 0x0008 (0x0008 - 0x0000)
struct FControlRigSequenceObjectReference final
{
public:
	TSubclassOf<class UControlRig>                ControlRigClass;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FControlRigSequenceObjectReference) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReference");
static_assert(sizeof(FControlRigSequenceObjectReference) == 0x000008, "Wrong size on FControlRigSequenceObjectReference");
static_assert(offsetof(FControlRigSequenceObjectReference, ControlRigClass) == 0x000000, "Member 'FControlRigSequenceObjectReference::ControlRigClass' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSequenceObjectReferences
// 0x0010 (0x0010 - 0x0000)
struct FControlRigSequenceObjectReferences final
{
public:
	TArray<struct FControlRigSequenceObjectReference> Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRigSequenceObjectReferences) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReferences");
static_assert(sizeof(FControlRigSequenceObjectReferences) == 0x000010, "Wrong size on FControlRigSequenceObjectReferences");
static_assert(offsetof(FControlRigSequenceObjectReferences, Array) == 0x000000, "Member 'FControlRigSequenceObjectReferences::Array' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigSequenceObjectReferenceMap
// 0x0020 (0x0020 - 0x0000)
struct FControlRigSequenceObjectReferenceMap final
{
public:
	TArray<struct FGuid>                          BindingIds;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FControlRigSequenceObjectReferences> References;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FControlRigSequenceObjectReferenceMap) == 0x000008, "Wrong alignment on FControlRigSequenceObjectReferenceMap");
static_assert(sizeof(FControlRigSequenceObjectReferenceMap) == 0x000020, "Wrong size on FControlRigSequenceObjectReferenceMap");
static_assert(offsetof(FControlRigSequenceObjectReferenceMap, BindingIds) == 0x000000, "Member 'FControlRigSequenceObjectReferenceMap::BindingIds' has a wrong offset!");
static_assert(offsetof(FControlRigSequenceObjectReferenceMap, References) == 0x000010, "Member 'FControlRigSequenceObjectReferenceMap::References' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorUnaryOp
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_MathVectorUnaryOp : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorUnaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathVectorUnaryOp");
static_assert(sizeof(FRigUnit_MathVectorUnaryOp) == 0x000038, "Wrong size on FRigUnit_MathVectorUnaryOp");
static_assert(offsetof(FRigUnit_MathVectorUnaryOp, Value) == 0x000020, "Member 'FRigUnit_MathVectorUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorUnaryOp, Result) == 0x00002C, "Member 'FRigUnit_MathVectorUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorRad
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorRad final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorRad) == 0x000008, "Wrong alignment on FRigUnit_MathVectorRad");
static_assert(sizeof(FRigUnit_MathVectorRad) == 0x000038, "Wrong size on FRigUnit_MathVectorRad");

// ScriptStruct ControlRig.RigUnit_BinaryVectorOp
// 0x0028 (0x0048 - 0x0020)
struct FRigUnit_BinaryVectorOp : public FRigUnit
{
public:
	struct FVector                                Argument0;                                         // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Argument1;                                         // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_BinaryVectorOp) == 0x000008, "Wrong alignment on FRigUnit_BinaryVectorOp");
static_assert(sizeof(FRigUnit_BinaryVectorOp) == 0x000048, "Wrong size on FRigUnit_BinaryVectorOp");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Argument0) == 0x000020, "Member 'FRigUnit_BinaryVectorOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Argument1) == 0x00002C, "Member 'FRigUnit_BinaryVectorOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryVectorOp, Result) == 0x000038, "Member 'FRigUnit_BinaryVectorOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Multiply_VectorVector
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_Multiply_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Multiply_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Multiply_VectorVector");
static_assert(sizeof(FRigUnit_Multiply_VectorVector) == 0x000048, "Wrong size on FRigUnit_Multiply_VectorVector");

// ScriptStruct ControlRig.RigUnit_SpringIK_DebugSettings
// 0x0050 (0x0050 - 0x0000)
struct FRigUnit_SpringIK_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpringIK_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_SpringIK_DebugSettings");
static_assert(sizeof(FRigUnit_SpringIK_DebugSettings) == 0x000050, "Wrong size on FRigUnit_SpringIK_DebugSettings");
static_assert(offsetof(FRigUnit_SpringIK_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_SpringIK_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_SpringIK_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_DebugSettings, Color) == 0x000008, "Member 'FRigUnit_SpringIK_DebugSettings::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK_DebugSettings, WorldOffset) == 0x000020, "Member 'FRigUnit_SpringIK_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BoneName
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_BoneName final : public FRigUnit
{
public:
	class FName                                   Bone;                                              // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BoneName) == 0x000008, "Wrong alignment on FRigUnit_BoneName");
static_assert(sizeof(FRigUnit_BoneName) == 0x000028, "Wrong size on FRigUnit_BoneName");
static_assert(offsetof(FRigUnit_BoneName, Bone) == 0x000020, "Member 'FRigUnit_BoneName::Bone' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugBaseMutable
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_DebugBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_DebugBaseMutable) == 0x000008, "Wrong alignment on FRigUnit_DebugBaseMutable");
static_assert(sizeof(FRigUnit_DebugBaseMutable) == 0x000038, "Wrong size on FRigUnit_DebugBaseMutable");

// ScriptStruct ControlRig.RigUnit_DebugTransformArrayMutable
// 0x0088 (0x00C0 - 0x0038)
struct FRigUnit_DebugTransformArrayMutable final : public FRigUnit_DebugBaseMutable
{
public:
	TArray<struct FTransform>                     Transforms;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ERigUnitDebugTransformMode                    Mode;                                              // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x004C(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0064(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0070(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     DrawTransforms;                                    // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugTransformArrayMutable) == 0x000010, "Wrong alignment on FRigUnit_DebugTransformArrayMutable");
static_assert(sizeof(FRigUnit_DebugTransformArrayMutable) == 0x0000C0, "Wrong size on FRigUnit_DebugTransformArrayMutable");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Transforms) == 0x000038, "Member 'FRigUnit_DebugTransformArrayMutable::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Mode) == 0x000048, "Member 'FRigUnit_DebugTransformArrayMutable::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Color) == 0x00004C, "Member 'FRigUnit_DebugTransformArrayMutable::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Thickness) == 0x00005C, "Member 'FRigUnit_DebugTransformArrayMutable::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Scale) == 0x000060, "Member 'FRigUnit_DebugTransformArrayMutable::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, Space) == 0x000064, "Member 'FRigUnit_DebugTransformArrayMutable::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, WorldOffset) == 0x000070, "Member 'FRigUnit_DebugTransformArrayMutable::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, bEnabled) == 0x0000A0, "Member 'FRigUnit_DebugTransformArrayMutable::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformArrayMutable, DrawTransforms) == 0x0000A8, "Member 'FRigUnit_DebugTransformArrayMutable::DrawTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_MathBoolBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathBoolBase) == 0x000008, "Wrong alignment on FRigUnit_MathBoolBase");
static_assert(sizeof(FRigUnit_MathBoolBase) == 0x000020, "Wrong size on FRigUnit_MathBoolBase");

// ScriptStruct ControlRig.RigUnit_MathBoolBinaryOp
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_MathBoolBinaryOp : public FRigUnit_MathBoolBase
{
public:
	bool                                          A;                                                 // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolBinaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathBoolBinaryOp");
static_assert(sizeof(FRigUnit_MathBoolBinaryOp) == 0x000028, "Wrong size on FRigUnit_MathBoolBinaryOp");
static_assert(offsetof(FRigUnit_MathBoolBinaryOp, A) == 0x000020, "Member 'FRigUnit_MathBoolBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolBinaryOp, B) == 0x000021, "Member 'FRigUnit_MathBoolBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolBinaryOp, Result) == 0x000022, "Member 'FRigUnit_MathBoolBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolAnd
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathBoolAnd final : public FRigUnit_MathBoolBinaryOp
{
};
static_assert(alignof(FRigUnit_MathBoolAnd) == 0x000008, "Wrong alignment on FRigUnit_MathBoolAnd");
static_assert(sizeof(FRigUnit_MathBoolAnd) == 0x000028, "Wrong size on FRigUnit_MathBoolAnd");

// ScriptStruct ControlRig.ControlRigSequencerAnimInstanceProxy
// 0x0180 (0x0A10 - 0x0890)
struct FControlRigSequencerAnimInstanceProxy final : public FAnimSequencerInstanceProxy
{
public:
	uint8                                         Pad_890[0x180];                                    // 0x0890(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigSequencerAnimInstanceProxy) == 0x000010, "Wrong alignment on FControlRigSequencerAnimInstanceProxy");
static_assert(sizeof(FControlRigSequencerAnimInstanceProxy) == 0x000A10, "Wrong size on FControlRigSequencerAnimInstanceProxy");

// ScriptStruct ControlRig.RigUnit_NoiseFloat
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_NoiseFloat final : public FRigUnit_MathBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_NoiseFloat) == 0x000008, "Wrong alignment on FRigUnit_NoiseFloat");
static_assert(sizeof(FRigUnit_NoiseFloat) == 0x000040, "Wrong size on FRigUnit_NoiseFloat");
static_assert(offsetof(FRigUnit_NoiseFloat, Value) == 0x000020, "Member 'FRigUnit_NoiseFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Speed) == 0x000024, "Member 'FRigUnit_NoiseFloat::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Frequency) == 0x000028, "Member 'FRigUnit_NoiseFloat::Frequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Minimum) == 0x00002C, "Member 'FRigUnit_NoiseFloat::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Maximum) == 0x000030, "Member 'FRigUnit_NoiseFloat::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Result) == 0x000034, "Member 'FRigUnit_NoiseFloat::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseFloat, Time) == 0x000038, "Member 'FRigUnit_NoiseFloat::Time' has a wrong offset!");

// ScriptStruct ControlRig.ControlRigIOVariable
// 0x0028 (0x0028 - 0x0000)
struct FControlRigIOVariable final
{
public:
	class FString                                 PropertyPath;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PropertyType;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Size;                                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRigIOVariable) == 0x000008, "Wrong alignment on FControlRigIOVariable");
static_assert(sizeof(FControlRigIOVariable) == 0x000028, "Wrong size on FControlRigIOVariable");
static_assert(offsetof(FControlRigIOVariable, PropertyPath) == 0x000000, "Member 'FControlRigIOVariable::PropertyPath' has a wrong offset!");
static_assert(offsetof(FControlRigIOVariable, PropertyType) == 0x000010, "Member 'FControlRigIOVariable::PropertyType' has a wrong offset!");
static_assert(offsetof(FControlRigIOVariable, Size) == 0x000020, "Member 'FControlRigIOVariable::Size' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMirror
// 0x0028 (0x0048 - 0x0020)
struct FRigUnit_MathVectorMirror final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorMirror) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMirror");
static_assert(sizeof(FRigUnit_MathVectorMirror) == 0x000048, "Wrong size on FRigUnit_MathVectorMirror");
static_assert(offsetof(FRigUnit_MathVectorMirror, Value) == 0x000020, "Member 'FRigUnit_MathVectorMirror::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorMirror, Normal) == 0x00002C, "Member 'FRigUnit_MathVectorMirror::Normal' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorMirror, Result) == 0x000038, "Member 'FRigUnit_MathVectorMirror::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateQuatLerp
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_AccumulateQuatLerp final : public FRigUnit_SimBase
{
public:
	struct FQuat                                  TargetValue;                                       // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  InitialValue;                                      // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0xB];                                       // 0x0045(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  AccumulatedValue;                                  // 0x0060(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateQuatLerp) == 0x000010, "Wrong alignment on FRigUnit_AccumulateQuatLerp");
static_assert(sizeof(FRigUnit_AccumulateQuatLerp) == 0x000070, "Wrong size on FRigUnit_AccumulateQuatLerp");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, TargetValue) == 0x000020, "Member 'FRigUnit_AccumulateQuatLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, InitialValue) == 0x000030, "Member 'FRigUnit_AccumulateQuatLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, Blend) == 0x000040, "Member 'FRigUnit_AccumulateQuatLerp::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, bIntegrateDeltaTime) == 0x000044, "Member 'FRigUnit_AccumulateQuatLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, Result) == 0x000050, "Member 'FRigUnit_AccumulateQuatLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatLerp, AccumulatedValue) == 0x000060, "Member 'FRigUnit_AccumulateQuatLerp::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurve_DebugSettings
// 0x0060 (0x0060 - 0x0000)
struct FRigUnit_FitChainToCurve_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CurveColor;                                        // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SegmentsColor;                                     // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0030(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FitChainToCurve_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_FitChainToCurve_DebugSettings");
static_assert(sizeof(FRigUnit_FitChainToCurve_DebugSettings) == 0x000060, "Wrong size on FRigUnit_FitChainToCurve_DebugSettings");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_FitChainToCurve_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_FitChainToCurve_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, CurveColor) == 0x000008, "Member 'FRigUnit_FitChainToCurve_DebugSettings::CurveColor' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, SegmentsColor) == 0x000018, "Member 'FRigUnit_FitChainToCurve_DebugSettings::SegmentsColor' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_DebugSettings, WorldOffset) == 0x000030, "Member 'FRigUnit_FitChainToCurve_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimEasing
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_AnimEasing final : public FRigUnit_AnimBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     Type;                                              // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SourceMinimum;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMaximum;                                     // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMinimum;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaximum;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AnimEasing) == 0x000008, "Wrong alignment on FRigUnit_AnimEasing");
static_assert(sizeof(FRigUnit_AnimEasing) == 0x000040, "Wrong size on FRigUnit_AnimEasing");
static_assert(offsetof(FRigUnit_AnimEasing, Value) == 0x000020, "Member 'FRigUnit_AnimEasing::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, Type) == 0x000024, "Member 'FRigUnit_AnimEasing::Type' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, SourceMinimum) == 0x000028, "Member 'FRigUnit_AnimEasing::SourceMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, SourceMaximum) == 0x00002C, "Member 'FRigUnit_AnimEasing::SourceMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, TargetMinimum) == 0x000030, "Member 'FRigUnit_AnimEasing::TargetMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, TargetMaximum) == 0x000034, "Member 'FRigUnit_AnimEasing::TargetMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AnimEasing, Result) == 0x000038, "Member 'FRigUnit_AnimEasing::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatConstant
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_MathFloatConstant : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatConstant) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstant");
static_assert(sizeof(FRigUnit_MathFloatConstant) == 0x000028, "Wrong size on FRigUnit_MathFloatConstant");
static_assert(offsetof(FRigUnit_MathFloatConstant, Value) == 0x000020, "Member 'FRigUnit_MathFloatConstant::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatConstHalfPi
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatConstHalfPi final : public FRigUnit_MathFloatConstant
{
};
static_assert(alignof(FRigUnit_MathFloatConstHalfPi) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstHalfPi");
static_assert(sizeof(FRigUnit_MathFloatConstHalfPi) == 0x000028, "Wrong size on FRigUnit_MathFloatConstHalfPi");

// ScriptStruct ControlRig.RigUnit_AccumulateFloatMul
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_AccumulateFloatMul final : public FRigUnit_SimBase
{
public:
	float                                         Multiplier;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialValue;                                      // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedValue;                                  // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateFloatMul) == 0x000008, "Wrong alignment on FRigUnit_AccumulateFloatMul");
static_assert(sizeof(FRigUnit_AccumulateFloatMul) == 0x000038, "Wrong size on FRigUnit_AccumulateFloatMul");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, Multiplier) == 0x000020, "Member 'FRigUnit_AccumulateFloatMul::Multiplier' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, InitialValue) == 0x000024, "Member 'FRigUnit_AccumulateFloatMul::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, bIntegrateDeltaTime) == 0x000028, "Member 'FRigUnit_AccumulateFloatMul::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, Result) == 0x00002C, "Member 'FRigUnit_AccumulateFloatMul::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatMul, AccumulatedValue) == 0x000030, "Member 'FRigUnit_AccumulateFloatMul::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigHierarchyRef
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRigHierarchyRef final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseBaseHierarchy;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigHierarchyRef) == 0x000008, "Wrong alignment on FRigHierarchyRef");
static_assert(sizeof(FRigHierarchyRef) == 0x000018, "Wrong size on FRigHierarchyRef");
static_assert(offsetof(FRigHierarchyRef, bUseBaseHierarchy) == 0x000008, "Member 'FRigHierarchyRef::bUseBaseHierarchy' has a wrong offset!");
static_assert(offsetof(FRigHierarchyRef, Name) == 0x00000C, "Member 'FRigHierarchyRef::Name' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimRichCurve
// 0x0088 (0x00A8 - 0x0020)
struct FRigUnit_AnimRichCurve final : public FRigUnit_AnimBase
{
public:
	struct FRuntimeFloatCurve                     Curve;                                             // 0x0020(0x0088)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AnimRichCurve) == 0x000008, "Wrong alignment on FRigUnit_AnimRichCurve");
static_assert(sizeof(FRigUnit_AnimRichCurve) == 0x0000A8, "Wrong size on FRigUnit_AnimRichCurve");
static_assert(offsetof(FRigUnit_AnimRichCurve, Curve) == 0x000020, "Member 'FRigUnit_AnimRichCurve::Curve' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_MathTransformBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathTransformBase) == 0x000008, "Wrong alignment on FRigUnit_MathTransformBase");
static_assert(sizeof(FRigUnit_MathTransformBase) == 0x000020, "Wrong size on FRigUnit_MathTransformBase");

// ScriptStruct ControlRig.RigUnit_MathTransformLerp
// 0x00A0 (0x00C0 - 0x0020)
struct FRigUnit_MathTransformLerp final : public FRigUnit_MathTransformBase
{
public:
	struct FTransform                             A;                                                 // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformLerp) == 0x000010, "Wrong alignment on FRigUnit_MathTransformLerp");
static_assert(sizeof(FRigUnit_MathTransformLerp) == 0x0000C0, "Wrong size on FRigUnit_MathTransformLerp");
static_assert(offsetof(FRigUnit_MathTransformLerp, A) == 0x000020, "Member 'FRigUnit_MathTransformLerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformLerp, B) == 0x000050, "Member 'FRigUnit_MathTransformLerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformLerp, T) == 0x000080, "Member 'FRigUnit_MathTransformLerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformLerp, Result) == 0x000090, "Member 'FRigUnit_MathTransformLerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.MovieSceneControlRigInstanceData
// 0x00D0 (0x00D8 - 0x0008)
struct FMovieSceneControlRigInstanceData final : public FMovieSceneSequenceInstanceData
{
public:
	bool                                          bAdditive;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBoneFilter;                                  // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputBlendPose                        BoneFilter;                                        // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                Weight;                                            // 0x0020(0x00A0)(NativeAccessSpecifierPublic)
	struct FMovieSceneEvaluationOperand           Operand;                                           // 0x00C0(0x0014)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovieSceneControlRigInstanceData) == 0x000008, "Wrong alignment on FMovieSceneControlRigInstanceData");
static_assert(sizeof(FMovieSceneControlRigInstanceData) == 0x0000D8, "Wrong size on FMovieSceneControlRigInstanceData");
static_assert(offsetof(FMovieSceneControlRigInstanceData, bAdditive) == 0x000008, "Member 'FMovieSceneControlRigInstanceData::bAdditive' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, bApplyBoneFilter) == 0x000009, "Member 'FMovieSceneControlRigInstanceData::bApplyBoneFilter' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, BoneFilter) == 0x000010, "Member 'FMovieSceneControlRigInstanceData::BoneFilter' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, Weight) == 0x000020, "Member 'FMovieSceneControlRigInstanceData::Weight' has a wrong offset!");
static_assert(offsetof(FMovieSceneControlRigInstanceData, Operand) == 0x0000C0, "Member 'FMovieSceneControlRigInstanceData::Operand' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetBoneTranslation
// 0x0020 (0x0058 - 0x0038)
struct FRigUnit_SetBoneTranslation final : public FRigUnitMutable
{
public:
	class FName                                   Bone;                                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x004D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedBoneIndex;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetBoneTranslation) == 0x000008, "Wrong alignment on FRigUnit_SetBoneTranslation");
static_assert(sizeof(FRigUnit_SetBoneTranslation) == 0x000058, "Wrong size on FRigUnit_SetBoneTranslation");
static_assert(offsetof(FRigUnit_SetBoneTranslation, Bone) == 0x000038, "Member 'FRigUnit_SetBoneTranslation::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, Translation) == 0x000040, "Member 'FRigUnit_SetBoneTranslation::Translation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, Space) == 0x00004C, "Member 'FRigUnit_SetBoneTranslation::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, bPropagateToChildren) == 0x00004D, "Member 'FRigUnit_SetBoneTranslation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTranslation, CachedBoneIndex) == 0x000050, "Member 'FRigUnit_SetBoneTranslation::CachedBoneIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateVectorRange
// 0x0040 (0x0060 - 0x0020)
struct FRigUnit_AccumulateVectorRange final : public FRigUnit_SimBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Minimum;                                           // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Maximum;                                           // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedMinimum;                                // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedMaximum;                                // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateVectorRange) == 0x000008, "Wrong alignment on FRigUnit_AccumulateVectorRange");
static_assert(sizeof(FRigUnit_AccumulateVectorRange) == 0x000060, "Wrong size on FRigUnit_AccumulateVectorRange");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, Value) == 0x000020, "Member 'FRigUnit_AccumulateVectorRange::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, Minimum) == 0x00002C, "Member 'FRigUnit_AccumulateVectorRange::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, Maximum) == 0x000038, "Member 'FRigUnit_AccumulateVectorRange::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, AccumulatedMinimum) == 0x000044, "Member 'FRigUnit_AccumulateVectorRange::AccumulatedMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorRange, AccumulatedMaximum) == 0x000050, "Member 'FRigUnit_AccumulateVectorRange::AccumulatedMaximum' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetRelativeBoneTransform
// 0x0058 (0x0090 - 0x0038)
struct FRigUnit_SetRelativeBoneTransform final : public FRigUnitMutable
{
public:
	class FName                                   Bone;                                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedBoneIndex;                                   // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedSpaceIndex;                                  // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetRelativeBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_SetRelativeBoneTransform");
static_assert(sizeof(FRigUnit_SetRelativeBoneTransform) == 0x000090, "Wrong size on FRigUnit_SetRelativeBoneTransform");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, Bone) == 0x000038, "Member 'FRigUnit_SetRelativeBoneTransform::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, Space) == 0x000040, "Member 'FRigUnit_SetRelativeBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, Transform) == 0x000050, "Member 'FRigUnit_SetRelativeBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, bPropagateToChildren) == 0x000080, "Member 'FRigUnit_SetRelativeBoneTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, CachedBoneIndex) == 0x000084, "Member 'FRigUnit_SetRelativeBoneTransform::CachedBoneIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetRelativeBoneTransform, CachedSpaceIndex) == 0x000088, "Member 'FRigUnit_SetRelativeBoneTransform::CachedSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateFloatRange
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_AccumulateFloatRange final : public FRigUnit_SimBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedMinimum;                                // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedMaximum;                                // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateFloatRange) == 0x000008, "Wrong alignment on FRigUnit_AccumulateFloatRange");
static_assert(sizeof(FRigUnit_AccumulateFloatRange) == 0x000038, "Wrong size on FRigUnit_AccumulateFloatRange");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, Value) == 0x000020, "Member 'FRigUnit_AccumulateFloatRange::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, Minimum) == 0x000024, "Member 'FRigUnit_AccumulateFloatRange::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, Maximum) == 0x000028, "Member 'FRigUnit_AccumulateFloatRange::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, AccumulatedMinimum) == 0x00002C, "Member 'FRigUnit_AccumulateFloatRange::AccumulatedMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateFloatRange, AccumulatedMaximum) == 0x000030, "Member 'FRigUnit_AccumulateFloatRange::AccumulatedMaximum' has a wrong offset!");

// ScriptStruct ControlRig.ConstraintTarget
// 0x0040 (0x0040 - 0x0000)
struct FConstraintTarget final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainOffset;                                   // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x0035(0x0009)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConstraintTarget) == 0x000010, "Wrong alignment on FConstraintTarget");
static_assert(sizeof(FConstraintTarget) == 0x000040, "Wrong size on FConstraintTarget");
static_assert(offsetof(FConstraintTarget, Transform) == 0x000000, "Member 'FConstraintTarget::Transform' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, Weight) == 0x000030, "Member 'FConstraintTarget::Weight' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, bMaintainOffset) == 0x000034, "Member 'FConstraintTarget::bMaintainOffset' has a wrong offset!");
static_assert(offsetof(FConstraintTarget, Filter) == 0x000035, "Member 'FConstraintTarget::Filter' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetInitialBoneTransform
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_GetInitialBoneTransform final : public FRigUnit
{
public:
	class FName                                   Bone;                                              // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0030(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CachedBoneIndex;                                   // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_GetInitialBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_GetInitialBoneTransform");
static_assert(sizeof(FRigUnit_GetInitialBoneTransform) == 0x000070, "Wrong size on FRigUnit_GetInitialBoneTransform");
static_assert(offsetof(FRigUnit_GetInitialBoneTransform, Bone) == 0x000020, "Member 'FRigUnit_GetInitialBoneTransform::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetInitialBoneTransform, Space) == 0x000028, "Member 'FRigUnit_GetInitialBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetInitialBoneTransform, Transform) == 0x000030, "Member 'FRigUnit_GetInitialBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetInitialBoneTransform, CachedBoneIndex) == 0x000060, "Member 'FRigUnit_GetInitialBoneTransform::CachedBoneIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BoneHarmonics_BoneTarget
// 0x000C (0x000C - 0x0000)
struct FRigUnit_BoneHarmonics_BoneTarget final
{
public:
	class FName                                   Bone;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BoneHarmonics_BoneTarget) == 0x000004, "Wrong alignment on FRigUnit_BoneHarmonics_BoneTarget");
static_assert(sizeof(FRigUnit_BoneHarmonics_BoneTarget) == 0x00000C, "Wrong size on FRigUnit_BoneHarmonics_BoneTarget");
static_assert(offsetof(FRigUnit_BoneHarmonics_BoneTarget, Bone) == 0x000000, "Member 'FRigUnit_BoneHarmonics_BoneTarget::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics_BoneTarget, Ratio) == 0x000008, "Member 'FRigUnit_BoneHarmonics_BoneTarget::Ratio' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateTransformLerp
// 0x00D0 (0x00F0 - 0x0020)
struct FRigUnit_AccumulateTransformLerp final : public FRigUnit_SimBase
{
public:
	struct FTransform                             TargetValue;                                       // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitialValue;                                      // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0xB];                                       // 0x0085(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             AccumulatedValue;                                  // 0x00C0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateTransformLerp) == 0x000010, "Wrong alignment on FRigUnit_AccumulateTransformLerp");
static_assert(sizeof(FRigUnit_AccumulateTransformLerp) == 0x0000F0, "Wrong size on FRigUnit_AccumulateTransformLerp");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, TargetValue) == 0x000020, "Member 'FRigUnit_AccumulateTransformLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, InitialValue) == 0x000050, "Member 'FRigUnit_AccumulateTransformLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, Blend) == 0x000080, "Member 'FRigUnit_AccumulateTransformLerp::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, bIntegrateDeltaTime) == 0x000084, "Member 'FRigUnit_AccumulateTransformLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, Result) == 0x000090, "Member 'FRigUnit_AccumulateTransformLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformLerp, AccumulatedValue) == 0x0000C0, "Member 'FRigUnit_AccumulateTransformLerp::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateVectorLerp
// 0x0038 (0x0058 - 0x0020)
struct FRigUnit_AccumulateVectorLerp final : public FRigUnit_SimBase
{
public:
	struct FVector                                TargetValue;                                       // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialValue;                                      // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedValue;                                  // 0x004C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateVectorLerp) == 0x000008, "Wrong alignment on FRigUnit_AccumulateVectorLerp");
static_assert(sizeof(FRigUnit_AccumulateVectorLerp) == 0x000058, "Wrong size on FRigUnit_AccumulateVectorLerp");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, TargetValue) == 0x000020, "Member 'FRigUnit_AccumulateVectorLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, InitialValue) == 0x00002C, "Member 'FRigUnit_AccumulateVectorLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, Blend) == 0x000038, "Member 'FRigUnit_AccumulateVectorLerp::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, bIntegrateDeltaTime) == 0x00003C, "Member 'FRigUnit_AccumulateVectorLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, Result) == 0x000040, "Member 'FRigUnit_AccumulateVectorLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorLerp, AccumulatedValue) == 0x00004C, "Member 'FRigUnit_AccumulateVectorLerp::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateTransformMul
// 0x00D0 (0x00F0 - 0x0020)
struct FRigUnit_AccumulateTransformMul final : public FRigUnit_SimBase
{
public:
	struct FTransform                             Multiplier;                                        // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitialValue;                                      // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bFlipOrder;                                        // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0xE];                                       // 0x0082(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             AccumulatedValue;                                  // 0x00C0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateTransformMul) == 0x000010, "Wrong alignment on FRigUnit_AccumulateTransformMul");
static_assert(sizeof(FRigUnit_AccumulateTransformMul) == 0x0000F0, "Wrong size on FRigUnit_AccumulateTransformMul");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, Multiplier) == 0x000020, "Member 'FRigUnit_AccumulateTransformMul::Multiplier' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, InitialValue) == 0x000050, "Member 'FRigUnit_AccumulateTransformMul::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, bFlipOrder) == 0x000080, "Member 'FRigUnit_AccumulateTransformMul::bFlipOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, bIntegrateDeltaTime) == 0x000081, "Member 'FRigUnit_AccumulateTransformMul::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, Result) == 0x000090, "Member 'FRigUnit_AccumulateTransformMul::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateTransformMul, AccumulatedValue) == 0x0000C0, "Member 'FRigUnit_AccumulateTransformMul::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorDeg
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorDeg final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorDeg) == 0x000008, "Wrong alignment on FRigUnit_MathVectorDeg");
static_assert(sizeof(FRigUnit_MathVectorDeg) == 0x000038, "Wrong size on FRigUnit_MathVectorDeg");

// ScriptStruct ControlRig.RigUnit_AccumulateQuatMul
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_AccumulateQuatMul final : public FRigUnit_SimBase
{
public:
	struct FQuat                                  Multiplier;                                        // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  InitialValue;                                      // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bFlipOrder;                                        // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  AccumulatedValue;                                  // 0x0060(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateQuatMul) == 0x000010, "Wrong alignment on FRigUnit_AccumulateQuatMul");
static_assert(sizeof(FRigUnit_AccumulateQuatMul) == 0x000070, "Wrong size on FRigUnit_AccumulateQuatMul");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, Multiplier) == 0x000020, "Member 'FRigUnit_AccumulateQuatMul::Multiplier' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, InitialValue) == 0x000030, "Member 'FRigUnit_AccumulateQuatMul::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, bFlipOrder) == 0x000040, "Member 'FRigUnit_AccumulateQuatMul::bFlipOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, bIntegrateDeltaTime) == 0x000041, "Member 'FRigUnit_AccumulateQuatMul::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, Result) == 0x000050, "Member 'FRigUnit_AccumulateQuatMul::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateQuatMul, AccumulatedValue) == 0x000060, "Member 'FRigUnit_AccumulateQuatMul::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateVectorMul
// 0x0038 (0x0058 - 0x0020)
struct FRigUnit_AccumulateVectorMul final : public FRigUnit_SimBase
{
public:
	struct FVector                                Multiplier;                                        // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialValue;                                      // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedValue;                                  // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateVectorMul) == 0x000008, "Wrong alignment on FRigUnit_AccumulateVectorMul");
static_assert(sizeof(FRigUnit_AccumulateVectorMul) == 0x000058, "Wrong size on FRigUnit_AccumulateVectorMul");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, Multiplier) == 0x000020, "Member 'FRigUnit_AccumulateVectorMul::Multiplier' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, InitialValue) == 0x00002C, "Member 'FRigUnit_AccumulateVectorMul::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, bIntegrateDeltaTime) == 0x000038, "Member 'FRigUnit_AccumulateVectorMul::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, Result) == 0x00003C, "Member 'FRigUnit_AccumulateVectorMul::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorMul, AccumulatedValue) == 0x000048, "Member 'FRigUnit_AccumulateVectorMul::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BoneHarmonics
// 0x0080 (0x00B8 - 0x0038)
struct FRigUnit_BoneHarmonics final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigUnit_BoneHarmonics_BoneTarget> Bones;                                             // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                WaveSpeed;                                         // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveFrequency;                                     // 0x0054(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveAmplitude;                                     // 0x0060(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveOffset;                                        // 0x006C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveNoise;                                         // 0x0078(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     WaveEase;                                          // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaveMinimum;                                       // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveMaximum;                                       // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigRotationOrder                      RotationOrder;                                     // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 BoneIndices;                                       // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                WaveTime;                                          // 0x00A8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_BoneHarmonics) == 0x000008, "Wrong alignment on FRigUnit_BoneHarmonics");
static_assert(sizeof(FRigUnit_BoneHarmonics) == 0x0000B8, "Wrong size on FRigUnit_BoneHarmonics");
static_assert(offsetof(FRigUnit_BoneHarmonics, Bones) == 0x000038, "Member 'FRigUnit_BoneHarmonics::Bones' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveSpeed) == 0x000048, "Member 'FRigUnit_BoneHarmonics::WaveSpeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveFrequency) == 0x000054, "Member 'FRigUnit_BoneHarmonics::WaveFrequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveAmplitude) == 0x000060, "Member 'FRigUnit_BoneHarmonics::WaveAmplitude' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveOffset) == 0x00006C, "Member 'FRigUnit_BoneHarmonics::WaveOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveNoise) == 0x000078, "Member 'FRigUnit_BoneHarmonics::WaveNoise' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveEase) == 0x000084, "Member 'FRigUnit_BoneHarmonics::WaveEase' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveMinimum) == 0x000088, "Member 'FRigUnit_BoneHarmonics::WaveMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveMaximum) == 0x00008C, "Member 'FRigUnit_BoneHarmonics::WaveMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, RotationOrder) == 0x000090, "Member 'FRigUnit_BoneHarmonics::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, bPropagateToChildren) == 0x000091, "Member 'FRigUnit_BoneHarmonics::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, BoneIndices) == 0x000098, "Member 'FRigUnit_BoneHarmonics::BoneIndices' has a wrong offset!");
static_assert(offsetof(FRigUnit_BoneHarmonics, WaveTime) == 0x0000A8, "Member 'FRigUnit_BoneHarmonics::WaveTime' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AccumulateVectorAdd
// 0x0038 (0x0058 - 0x0020)
struct FRigUnit_AccumulateVectorAdd final : public FRigUnit_SimBase
{
public:
	struct FVector                                Increment;                                         // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialValue;                                      // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedValue;                                  // 0x0048(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AccumulateVectorAdd) == 0x000008, "Wrong alignment on FRigUnit_AccumulateVectorAdd");
static_assert(sizeof(FRigUnit_AccumulateVectorAdd) == 0x000058, "Wrong size on FRigUnit_AccumulateVectorAdd");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, Increment) == 0x000020, "Member 'FRigUnit_AccumulateVectorAdd::Increment' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, InitialValue) == 0x00002C, "Member 'FRigUnit_AccumulateVectorAdd::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, bIntegrateDeltaTime) == 0x000038, "Member 'FRigUnit_AccumulateVectorAdd::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, Result) == 0x00003C, "Member 'FRigUnit_AccumulateVectorAdd::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateVectorAdd, AccumulatedValue) == 0x000048, "Member 'FRigUnit_AccumulateVectorAdd::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_MathQuaternionBase : public FRigUnit_MathBase
{
};
static_assert(alignof(FRigUnit_MathQuaternionBase) == 0x000008, "Wrong alignment on FRigUnit_MathQuaternionBase");
static_assert(sizeof(FRigUnit_MathQuaternionBase) == 0x000020, "Wrong size on FRigUnit_MathQuaternionBase");

// ScriptStruct ControlRig.RigUnit_MathQuaternionBinaryOp
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MathQuaternionBinaryOp : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  A;                                                 // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionBinaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionBinaryOp");
static_assert(sizeof(FRigUnit_MathQuaternionBinaryOp) == 0x000050, "Wrong size on FRigUnit_MathQuaternionBinaryOp");
static_assert(offsetof(FRigUnit_MathQuaternionBinaryOp, A) == 0x000020, "Member 'FRigUnit_MathQuaternionBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionBinaryOp, B) == 0x000030, "Member 'FRigUnit_MathQuaternionBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionBinaryOp, Result) == 0x000040, "Member 'FRigUnit_MathQuaternionBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AddBoneTransform
// 0x0048 (0x0080 - 0x0038)
struct FRigUnit_AddBoneTransform final : public FRigUnitMutable
{
public:
	class FName                                   Bone;                                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPostMultiply;                                     // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedBoneIndex;                                   // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AddBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_AddBoneTransform");
static_assert(sizeof(FRigUnit_AddBoneTransform) == 0x000080, "Wrong size on FRigUnit_AddBoneTransform");
static_assert(offsetof(FRigUnit_AddBoneTransform, Bone) == 0x000038, "Member 'FRigUnit_AddBoneTransform::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, Transform) == 0x000040, "Member 'FRigUnit_AddBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, bPostMultiply) == 0x000070, "Member 'FRigUnit_AddBoneTransform::bPostMultiply' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, bPropagateToChildren) == 0x000071, "Member 'FRigUnit_AddBoneTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_AddBoneTransform, CachedBoneIndex) == 0x000074, "Member 'FRigUnit_AddBoneTransform::CachedBoneIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatRemap
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathFloatRemap final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMinimum;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceMaximum;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMinimum;                                     // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMaximum;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClamp;                                            // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatRemap) == 0x000008, "Wrong alignment on FRigUnit_MathFloatRemap");
static_assert(sizeof(FRigUnit_MathFloatRemap) == 0x000040, "Wrong size on FRigUnit_MathFloatRemap");
static_assert(offsetof(FRigUnit_MathFloatRemap, Value) == 0x000020, "Member 'FRigUnit_MathFloatRemap::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, SourceMinimum) == 0x000024, "Member 'FRigUnit_MathFloatRemap::SourceMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, SourceMaximum) == 0x000028, "Member 'FRigUnit_MathFloatRemap::SourceMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, TargetMinimum) == 0x00002C, "Member 'FRigUnit_MathFloatRemap::TargetMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, TargetMaximum) == 0x000030, "Member 'FRigUnit_MathFloatRemap::TargetMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, bClamp) == 0x000034, "Member 'FRigUnit_MathFloatRemap::bClamp' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatRemap, Result) == 0x000038, "Member 'FRigUnit_MathFloatRemap::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionRotationOrder
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_MathQuaternionRotationOrder final : public FRigUnit_MathBase
{
public:
	EControlRigRotationOrder                      RotationOrder;                                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionRotationOrder) == 0x000008, "Wrong alignment on FRigUnit_MathQuaternionRotationOrder");
static_assert(sizeof(FRigUnit_MathQuaternionRotationOrder) == 0x000028, "Wrong size on FRigUnit_MathQuaternionRotationOrder");
static_assert(offsetof(FRigUnit_MathQuaternionRotationOrder, RotationOrder) == 0x000020, "Member 'FRigUnit_MathQuaternionRotationOrder::RotationOrder' has a wrong offset!");

// ScriptStruct ControlRig.AimTarget
// 0x0050 (0x0050 - 0x0000)
struct FAimTarget final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AlignVector;                                       // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimTarget) == 0x000010, "Wrong alignment on FAimTarget");
static_assert(sizeof(FAimTarget) == 0x000050, "Wrong size on FAimTarget");
static_assert(offsetof(FAimTarget, Weight) == 0x000000, "Member 'FAimTarget::Weight' has a wrong offset!");
static_assert(offsetof(FAimTarget, Transform) == 0x000010, "Member 'FAimTarget::Transform' has a wrong offset!");
static_assert(offsetof(FAimTarget, AlignVector) == 0x000040, "Member 'FAimTarget::AlignVector' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AimConstraint
// 0x0058 (0x0090 - 0x0038)
struct FRigUnit_AimConstraint final : public FRigUnitMutable
{
public:
	class FName                                   Joint;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAimMode                                      AimMode;                                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAimMode                                      UpMode;                                            // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimVector;                                         // 0x0044(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                UpVector;                                          // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAimTarget>                     AimTargets;                                        // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FAimTarget>                     UpTargets;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AimConstraint) == 0x000008, "Wrong alignment on FRigUnit_AimConstraint");
static_assert(sizeof(FRigUnit_AimConstraint) == 0x000090, "Wrong size on FRigUnit_AimConstraint");
static_assert(offsetof(FRigUnit_AimConstraint, Joint) == 0x000038, "Member 'FRigUnit_AimConstraint::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimMode) == 0x000040, "Member 'FRigUnit_AimConstraint::AimMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpMode) == 0x000041, "Member 'FRigUnit_AimConstraint::UpMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimVector) == 0x000044, "Member 'FRigUnit_AimConstraint::AimVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpVector) == 0x000050, "Member 'FRigUnit_AimConstraint::UpVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, AimTargets) == 0x000060, "Member 'FRigUnit_AimConstraint::AimTargets' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimConstraint, UpTargets) == 0x000070, "Member 'FRigUnit_AimConstraint::UpTargets' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryFloatOp
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_BinaryFloatOp : public FRigUnit
{
public:
	float                                         Argument0;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Argument1;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_BinaryFloatOp) == 0x000008, "Wrong alignment on FRigUnit_BinaryFloatOp");
static_assert(sizeof(FRigUnit_BinaryFloatOp) == 0x000030, "Wrong size on FRigUnit_BinaryFloatOp");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Argument0) == 0x000020, "Member 'FRigUnit_BinaryFloatOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Argument1) == 0x000024, "Member 'FRigUnit_BinaryFloatOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryFloatOp, Result) == 0x000028, "Member 'FRigUnit_BinaryFloatOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Add_FloatFloat
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_Add_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Add_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Add_FloatFloat");
static_assert(sizeof(FRigUnit_Add_FloatFloat) == 0x000030, "Wrong size on FRigUnit_Add_FloatFloat");

// ScriptStruct ControlRig.BlendTarget
// 0x0040 (0x0040 - 0x0000)
struct FBlendTarget final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlendTarget) == 0x000010, "Wrong alignment on FBlendTarget");
static_assert(sizeof(FBlendTarget) == 0x000040, "Wrong size on FBlendTarget");
static_assert(offsetof(FBlendTarget, Transform) == 0x000000, "Member 'FBlendTarget::Transform' has a wrong offset!");
static_assert(offsetof(FBlendTarget, Weight) == 0x000030, "Member 'FBlendTarget::Weight' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_AnimEasingType
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_AnimEasingType final : public FRigUnit_AnimBase
{
public:
	EControlRigAnimEasingType                     Type;                                              // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AnimEasingType) == 0x000008, "Wrong alignment on FRigUnit_AnimEasingType");
static_assert(sizeof(FRigUnit_AnimEasingType) == 0x000028, "Wrong size on FRigUnit_AnimEasingType");
static_assert(offsetof(FRigUnit_AnimEasingType, Type) == 0x000020, "Member 'FRigUnit_AnimEasingType::Type' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ToSwingAndTwist
// 0x0040 (0x0060 - 0x0020)
struct FRigUnit_ToSwingAndTwist final : public FRigUnit
{
public:
	struct FQuat                                  Input;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TwistAxis;                                         // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Swing;                                             // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Twist;                                             // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ToSwingAndTwist) == 0x000010, "Wrong alignment on FRigUnit_ToSwingAndTwist");
static_assert(sizeof(FRigUnit_ToSwingAndTwist) == 0x000060, "Wrong size on FRigUnit_ToSwingAndTwist");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Input) == 0x000020, "Member 'FRigUnit_ToSwingAndTwist::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, TwistAxis) == 0x000030, "Member 'FRigUnit_ToSwingAndTwist::TwistAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Swing) == 0x000040, "Member 'FRigUnit_ToSwingAndTwist::Swing' has a wrong offset!");
static_assert(offsetof(FRigUnit_ToSwingAndTwist, Twist) == 0x000050, "Member 'FRigUnit_ToSwingAndTwist::Twist' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ApplyFK
// 0x0088 (0x00C0 - 0x0038)
struct FRigUnit_ApplyFK final : public FRigUnitMutable
{
public:
	class FName                                   Joint;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x0070(0x0009)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EApplyTransformMode                           ApplyTransformMode;                                // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           ApplyTransformSpace;                               // 0x007A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0080(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseJoint;                                         // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ApplyFK) == 0x000010, "Wrong alignment on FRigUnit_ApplyFK");
static_assert(sizeof(FRigUnit_ApplyFK) == 0x0000C0, "Wrong size on FRigUnit_ApplyFK");
static_assert(offsetof(FRigUnit_ApplyFK, Joint) == 0x000038, "Member 'FRigUnit_ApplyFK::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, Transform) == 0x000040, "Member 'FRigUnit_ApplyFK::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, Filter) == 0x000070, "Member 'FRigUnit_ApplyFK::Filter' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, ApplyTransformMode) == 0x000079, "Member 'FRigUnit_ApplyFK::ApplyTransformMode' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, ApplyTransformSpace) == 0x00007A, "Member 'FRigUnit_ApplyFK::ApplyTransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, BaseTransform) == 0x000080, "Member 'FRigUnit_ApplyFK::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFK, BaseJoint) == 0x0000B0, "Member 'FRigUnit_ApplyFK::BaseJoint' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BeginExecution
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_BeginExecution final : public FRigUnit
{
public:
	struct FControlRigExecuteContext              ExecuteContext;                                    // 0x0020(0x0018)(Edit, Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BeginExecution) == 0x000008, "Wrong alignment on FRigUnit_BeginExecution");
static_assert(sizeof(FRigUnit_BeginExecution) == 0x000038, "Wrong size on FRigUnit_BeginExecution");
static_assert(offsetof(FRigUnit_BeginExecution, ExecuteContext) == 0x000020, "Member 'FRigUnit_BeginExecution::ExecuteContext' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BlendTransform
// 0x0070 (0x0090 - 0x0020)
struct FRigUnit_BlendTransform final : public FRigUnit
{
public:
	struct FTransform                             Source;                                            // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBlendTarget>                   Targets;                                           // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0060(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BlendTransform) == 0x000010, "Wrong alignment on FRigUnit_BlendTransform");
static_assert(sizeof(FRigUnit_BlendTransform) == 0x000090, "Wrong size on FRigUnit_BlendTransform");
static_assert(offsetof(FRigUnit_BlendTransform, Source) == 0x000020, "Member 'FRigUnit_BlendTransform::Source' has a wrong offset!");
static_assert(offsetof(FRigUnit_BlendTransform, Targets) == 0x000050, "Member 'FRigUnit_BlendTransform::Targets' has a wrong offset!");
static_assert(offsetof(FRigUnit_BlendTransform, Result) == 0x000060, "Member 'FRigUnit_BlendTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics_Reach
// 0x0028 (0x0028 - 0x0000)
struct FRigUnit_ChainHarmonics_Reach final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReachTarget;                                       // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReachAxis;                                         // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachMinimum;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachMaximum;                                      // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     ReachEase;                                         // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ChainHarmonics_Reach) == 0x000004, "Wrong alignment on FRigUnit_ChainHarmonics_Reach");
static_assert(sizeof(FRigUnit_ChainHarmonics_Reach) == 0x000028, "Wrong size on FRigUnit_ChainHarmonics_Reach");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, bEnabled) == 0x000000, "Member 'FRigUnit_ChainHarmonics_Reach::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachTarget) == 0x000004, "Member 'FRigUnit_ChainHarmonics_Reach::ReachTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachAxis) == 0x000010, "Member 'FRigUnit_ChainHarmonics_Reach::ReachAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachMinimum) == 0x00001C, "Member 'FRigUnit_ChainHarmonics_Reach::ReachMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachMaximum) == 0x000020, "Member 'FRigUnit_ChainHarmonics_Reach::ReachMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Reach, ReachEase) == 0x000024, "Member 'FRigUnit_ChainHarmonics_Reach::ReachEase' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics_Wave
// 0x0040 (0x0040 - 0x0000)
struct FRigUnit_ChainHarmonics_Wave final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WaveFrequency;                                     // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveAmplitude;                                     // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveOffset;                                        // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WaveNoise;                                         // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveMinimum;                                       // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveMaximum;                                       // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     WaveEase;                                          // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ChainHarmonics_Wave) == 0x000004, "Wrong alignment on FRigUnit_ChainHarmonics_Wave");
static_assert(sizeof(FRigUnit_ChainHarmonics_Wave) == 0x000040, "Wrong size on FRigUnit_ChainHarmonics_Wave");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, bEnabled) == 0x000000, "Member 'FRigUnit_ChainHarmonics_Wave::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveFrequency) == 0x000004, "Member 'FRigUnit_ChainHarmonics_Wave::WaveFrequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveAmplitude) == 0x000010, "Member 'FRigUnit_ChainHarmonics_Wave::WaveAmplitude' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveOffset) == 0x00001C, "Member 'FRigUnit_ChainHarmonics_Wave::WaveOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveNoise) == 0x000028, "Member 'FRigUnit_ChainHarmonics_Wave::WaveNoise' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveMinimum) == 0x000034, "Member 'FRigUnit_ChainHarmonics_Wave::WaveMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveMaximum) == 0x000038, "Member 'FRigUnit_ChainHarmonics_Wave::WaveMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Wave, WaveEase) == 0x00003C, "Member 'FRigUnit_ChainHarmonics_Wave::WaveEase' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics_Pendulum
// 0x003C (0x003C - 0x0000)
struct FRigUnit_ChainHarmonics_Pendulum final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PendulumStiffness;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PendulumGravity;                                   // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendulumBlend;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendulumDrag;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendulumMinimum;                                   // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendulumMaximum;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     PendulumEase;                                      // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UnwindAxis;                                        // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnwindMinimum;                                     // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnwindMaximum;                                     // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ChainHarmonics_Pendulum) == 0x000004, "Wrong alignment on FRigUnit_ChainHarmonics_Pendulum");
static_assert(sizeof(FRigUnit_ChainHarmonics_Pendulum) == 0x00003C, "Wrong size on FRigUnit_ChainHarmonics_Pendulum");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, bEnabled) == 0x000000, "Member 'FRigUnit_ChainHarmonics_Pendulum::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumStiffness) == 0x000004, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumStiffness' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumGravity) == 0x000008, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumGravity' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumBlend) == 0x000014, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumBlend' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumDrag) == 0x000018, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumDrag' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumMinimum) == 0x00001C, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumMaximum) == 0x000020, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, PendulumEase) == 0x000024, "Member 'FRigUnit_ChainHarmonics_Pendulum::PendulumEase' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, UnwindAxis) == 0x000028, "Member 'FRigUnit_ChainHarmonics_Pendulum::UnwindAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, UnwindMinimum) == 0x000034, "Member 'FRigUnit_ChainHarmonics_Pendulum::UnwindMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics_Pendulum, UnwindMaximum) == 0x000038, "Member 'FRigUnit_ChainHarmonics_Pendulum::UnwindMaximum' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ChainHarmonics
// 0x0208 (0x0240 - 0x0038)
struct FRigUnit_ChainHarmonics final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   ChainRoot;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Speed;                                             // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Reach          Reach;                                             // 0x004C(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Wave           Wave;                                              // 0x0074(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     WaveCurve;                                         // 0x00B8(0x0088)(NativeAccessSpecifierPublic)
	struct FRigUnit_ChainHarmonics_Pendulum       Pendulum;                                          // 0x0140(0x003C)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x017C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DrawWorldOffset;                                   // 0x0180(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Time;                                              // 0x01B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Bones;                                             // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Ratio;                                             // 0x01D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        LocalTip;                                          // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PendulumTip;                                       // 0x01F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PendulumPosition;                                  // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PendulumVelocity;                                  // 0x0210(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        HierarchyLine;                                     // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        VelocityLines;                                     // 0x0230(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ChainHarmonics) == 0x000010, "Wrong alignment on FRigUnit_ChainHarmonics");
static_assert(sizeof(FRigUnit_ChainHarmonics) == 0x000240, "Wrong size on FRigUnit_ChainHarmonics");
static_assert(offsetof(FRigUnit_ChainHarmonics, ChainRoot) == 0x000038, "Member 'FRigUnit_ChainHarmonics::ChainRoot' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Speed) == 0x000040, "Member 'FRigUnit_ChainHarmonics::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Reach) == 0x00004C, "Member 'FRigUnit_ChainHarmonics::Reach' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Wave) == 0x000074, "Member 'FRigUnit_ChainHarmonics::Wave' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, WaveCurve) == 0x0000B8, "Member 'FRigUnit_ChainHarmonics::WaveCurve' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Pendulum) == 0x000140, "Member 'FRigUnit_ChainHarmonics::Pendulum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, bDrawDebug) == 0x00017C, "Member 'FRigUnit_ChainHarmonics::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, DrawWorldOffset) == 0x000180, "Member 'FRigUnit_ChainHarmonics::DrawWorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Time) == 0x0001B0, "Member 'FRigUnit_ChainHarmonics::Time' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Bones) == 0x0001C0, "Member 'FRigUnit_ChainHarmonics::Bones' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, Ratio) == 0x0001D0, "Member 'FRigUnit_ChainHarmonics::Ratio' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, LocalTip) == 0x0001E0, "Member 'FRigUnit_ChainHarmonics::LocalTip' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, PendulumTip) == 0x0001F0, "Member 'FRigUnit_ChainHarmonics::PendulumTip' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, PendulumPosition) == 0x000200, "Member 'FRigUnit_ChainHarmonics::PendulumPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, PendulumVelocity) == 0x000210, "Member 'FRigUnit_ChainHarmonics::PendulumVelocity' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, HierarchyLine) == 0x000220, "Member 'FRigUnit_ChainHarmonics::HierarchyLine' has a wrong offset!");
static_assert(offsetof(FRigUnit_ChainHarmonics, VelocityLines) == 0x000230, "Member 'FRigUnit_ChainHarmonics::VelocityLines' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DistributeRotation_Rotation
// 0x0020 (0x0020 - 0x0000)
struct FRigUnit_DistributeRotation_Rotation final
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DistributeRotation_Rotation) == 0x000010, "Wrong alignment on FRigUnit_DistributeRotation_Rotation");
static_assert(sizeof(FRigUnit_DistributeRotation_Rotation) == 0x000020, "Wrong size on FRigUnit_DistributeRotation_Rotation");
static_assert(offsetof(FRigUnit_DistributeRotation_Rotation, Rotation) == 0x000000, "Member 'FRigUnit_DistributeRotation_Rotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation_Rotation, Ratio) == 0x000010, "Member 'FRigUnit_DistributeRotation_Rotation::Ratio' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatLawOfCosine
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathFloatLawOfCosine final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         C;                                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlphaAngle;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BetaAngle;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GammaAngle;                                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValid;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatLawOfCosine) == 0x000008, "Wrong alignment on FRigUnit_MathFloatLawOfCosine");
static_assert(sizeof(FRigUnit_MathFloatLawOfCosine) == 0x000040, "Wrong size on FRigUnit_MathFloatLawOfCosine");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, A) == 0x000020, "Member 'FRigUnit_MathFloatLawOfCosine::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, B) == 0x000024, "Member 'FRigUnit_MathFloatLawOfCosine::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, C) == 0x000028, "Member 'FRigUnit_MathFloatLawOfCosine::C' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, AlphaAngle) == 0x00002C, "Member 'FRigUnit_MathFloatLawOfCosine::AlphaAngle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, BetaAngle) == 0x000030, "Member 'FRigUnit_MathFloatLawOfCosine::BetaAngle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, GammaAngle) == 0x000034, "Member 'FRigUnit_MathFloatLawOfCosine::GammaAngle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLawOfCosine, bValid) == 0x000038, "Member 'FRigUnit_MathFloatLawOfCosine::bValid' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Control
// 0x00D0 (0x00F0 - 0x0020)
struct FRigUnit_Control : public FRigUnit
{
public:
	struct FEulerTransform                        Transform;                                         // 0x0020(0x0024)(Edit, BlueprintVisible, Interp, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Base;                                              // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             InitTransform;                                     // 0x0080(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x00B0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransformFilter                       Filter;                                            // 0x00E0(0x0009)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Control) == 0x000010, "Wrong alignment on FRigUnit_Control");
static_assert(sizeof(FRigUnit_Control) == 0x0000F0, "Wrong size on FRigUnit_Control");
static_assert(offsetof(FRigUnit_Control, Transform) == 0x000020, "Member 'FRigUnit_Control::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Base) == 0x000050, "Member 'FRigUnit_Control::Base' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, InitTransform) == 0x000080, "Member 'FRigUnit_Control::InitTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Result) == 0x0000B0, "Member 'FRigUnit_Control::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_Control, Filter) == 0x0000E0, "Member 'FRigUnit_Control::Filter' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Control_StaticMesh
// 0x0000 (0x00F0 - 0x00F0)
struct FRigUnit_Control_StaticMesh final : public FRigUnit_Control
{
};
static_assert(alignof(FRigUnit_Control_StaticMesh) == 0x000010, "Wrong alignment on FRigUnit_Control_StaticMesh");
static_assert(sizeof(FRigUnit_Control_StaticMesh) == 0x0000F0, "Wrong size on FRigUnit_Control_StaticMesh");

// ScriptStruct ControlRig.RigUnit_MathFloatTan
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatTan final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatTan) == 0x000008, "Wrong alignment on FRigUnit_MathFloatTan");
static_assert(sizeof(FRigUnit_MathFloatTan) == 0x000028, "Wrong size on FRigUnit_MathFloatTan");

// ScriptStruct ControlRig.RigUnit_ConvertQuaternionToVector
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_ConvertQuaternionToVector final : public FRigUnit
{
public:
	struct FQuat                                  Input;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertQuaternionToVector) == 0x000010, "Wrong alignment on FRigUnit_ConvertQuaternionToVector");
static_assert(sizeof(FRigUnit_ConvertQuaternionToVector) == 0x000040, "Wrong size on FRigUnit_ConvertQuaternionToVector");
static_assert(offsetof(FRigUnit_ConvertQuaternionToVector, Input) == 0x000020, "Member 'FRigUnit_ConvertQuaternionToVector::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertQuaternionToVector, Result) == 0x000030, "Member 'FRigUnit_ConvertQuaternionToVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertRotationToVector
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_ConvertRotationToVector final : public FRigUnit
{
public:
	struct FRotator                               Input;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertRotationToVector) == 0x000008, "Wrong alignment on FRigUnit_ConvertRotationToVector");
static_assert(sizeof(FRigUnit_ConvertRotationToVector) == 0x000038, "Wrong size on FRigUnit_ConvertRotationToVector");
static_assert(offsetof(FRigUnit_ConvertRotationToVector, Input) == 0x000020, "Member 'FRigUnit_ConvertRotationToVector::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertRotationToVector, Result) == 0x00002C, "Member 'FRigUnit_ConvertRotationToVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertVectorToQuaternion
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_ConvertVectorToQuaternion final : public FRigUnit
{
public:
	struct FVector                                Input;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertVectorToQuaternion) == 0x000010, "Wrong alignment on FRigUnit_ConvertVectorToQuaternion");
static_assert(sizeof(FRigUnit_ConvertVectorToQuaternion) == 0x000040, "Wrong size on FRigUnit_ConvertVectorToQuaternion");
static_assert(offsetof(FRigUnit_ConvertVectorToQuaternion, Input) == 0x000020, "Member 'FRigUnit_ConvertVectorToQuaternion::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertVectorToQuaternion, Result) == 0x000030, "Member 'FRigUnit_ConvertVectorToQuaternion::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertVectorToRotation
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_ConvertVectorToRotation final : public FRigUnit
{
public:
	struct FVector                                Input;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Result;                                            // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertVectorToRotation) == 0x000008, "Wrong alignment on FRigUnit_ConvertVectorToRotation");
static_assert(sizeof(FRigUnit_ConvertVectorToRotation) == 0x000038, "Wrong size on FRigUnit_ConvertVectorToRotation");
static_assert(offsetof(FRigUnit_ConvertVectorToRotation, Input) == 0x000020, "Member 'FRigUnit_ConvertVectorToRotation::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertVectorToRotation, Result) == 0x00002C, "Member 'FRigUnit_ConvertVectorToRotation::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorFromFloat
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathVectorFromFloat final : public FRigUnit_MathVectorBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorFromFloat) == 0x000008, "Wrong alignment on FRigUnit_MathVectorFromFloat");
static_assert(sizeof(FRigUnit_MathVectorFromFloat) == 0x000030, "Wrong size on FRigUnit_MathVectorFromFloat");
static_assert(offsetof(FRigUnit_MathVectorFromFloat, Value) == 0x000020, "Member 'FRigUnit_MathVectorFromFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorFromFloat, Result) == 0x000024, "Member 'FRigUnit_MathVectorFromFloat::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertQuaternion
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_ConvertQuaternion final : public FRigUnit
{
public:
	struct FQuat                                  Input;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Result;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertQuaternion) == 0x000010, "Wrong alignment on FRigUnit_ConvertQuaternion");
static_assert(sizeof(FRigUnit_ConvertQuaternion) == 0x000040, "Wrong size on FRigUnit_ConvertQuaternion");
static_assert(offsetof(FRigUnit_ConvertQuaternion, Input) == 0x000020, "Member 'FRigUnit_ConvertQuaternion::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertQuaternion, Result) == 0x000030, "Member 'FRigUnit_ConvertQuaternion::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertRotation
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_ConvertRotation : public FRigUnit
{
public:
	struct FRotator                               Input;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertRotation) == 0x000010, "Wrong alignment on FRigUnit_ConvertRotation");
static_assert(sizeof(FRigUnit_ConvertRotation) == 0x000040, "Wrong size on FRigUnit_ConvertRotation");
static_assert(offsetof(FRigUnit_ConvertRotation, Input) == 0x000020, "Member 'FRigUnit_ConvertRotation::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertRotation, Result) == 0x000030, "Member 'FRigUnit_ConvertRotation::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertVectorRotation
// 0x0000 (0x0040 - 0x0040)
struct FRigUnit_ConvertVectorRotation final : public FRigUnit_ConvertRotation
{
};
static_assert(alignof(FRigUnit_ConvertVectorRotation) == 0x000010, "Wrong alignment on FRigUnit_ConvertVectorRotation");
static_assert(sizeof(FRigUnit_ConvertVectorRotation) == 0x000040, "Wrong size on FRigUnit_ConvertVectorRotation");

// ScriptStruct ControlRig.RigUnit_ConvertEulerTransform
// 0x0060 (0x0080 - 0x0020)
struct FRigUnit_ConvertEulerTransform final : public FRigUnit
{
public:
	struct FEulerTransform                        Input;                                             // 0x0020(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ConvertEulerTransform) == 0x000010, "Wrong alignment on FRigUnit_ConvertEulerTransform");
static_assert(sizeof(FRigUnit_ConvertEulerTransform) == 0x000080, "Wrong size on FRigUnit_ConvertEulerTransform");
static_assert(offsetof(FRigUnit_ConvertEulerTransform, Input) == 0x000020, "Member 'FRigUnit_ConvertEulerTransform::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertEulerTransform, Result) == 0x000050, "Member 'FRigUnit_ConvertEulerTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ConvertTransform
// 0x0060 (0x0080 - 0x0020)
struct FRigUnit_ConvertTransform final : public FRigUnit
{
public:
	struct FTransform                             Input;                                             // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEulerTransform                        Result;                                            // 0x0050(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ConvertTransform) == 0x000010, "Wrong alignment on FRigUnit_ConvertTransform");
static_assert(sizeof(FRigUnit_ConvertTransform) == 0x000080, "Wrong size on FRigUnit_ConvertTransform");
static_assert(offsetof(FRigUnit_ConvertTransform, Input) == 0x000020, "Member 'FRigUnit_ConvertTransform::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ConvertTransform, Result) == 0x000050, "Member 'FRigUnit_ConvertTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_CreateHierarchy
// 0x0038 (0x0058 - 0x0020)
struct FRigUnit_CreateHierarchy final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       NewHierarchy;                                      // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigHierarchyRef                       SourceHierarchy;                                   // 0x0038(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Root;                                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_CreateHierarchy) == 0x000008, "Wrong alignment on FRigUnit_CreateHierarchy");
static_assert(sizeof(FRigUnit_CreateHierarchy) == 0x000058, "Wrong size on FRigUnit_CreateHierarchy");
static_assert(offsetof(FRigUnit_CreateHierarchy, NewHierarchy) == 0x000020, "Member 'FRigUnit_CreateHierarchy::NewHierarchy' has a wrong offset!");
static_assert(offsetof(FRigUnit_CreateHierarchy, SourceHierarchy) == 0x000038, "Member 'FRigUnit_CreateHierarchy::SourceHierarchy' has a wrong offset!");
static_assert(offsetof(FRigUnit_CreateHierarchy, Root) == 0x000050, "Member 'FRigUnit_CreateHierarchy::Root' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DeltaFromPreviousVector
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_DeltaFromPreviousVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Delta;                                             // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousValue;                                     // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Cache;                                             // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DeltaFromPreviousVector) == 0x000008, "Wrong alignment on FRigUnit_DeltaFromPreviousVector");
static_assert(sizeof(FRigUnit_DeltaFromPreviousVector) == 0x000050, "Wrong size on FRigUnit_DeltaFromPreviousVector");
static_assert(offsetof(FRigUnit_DeltaFromPreviousVector, Value) == 0x000020, "Member 'FRigUnit_DeltaFromPreviousVector::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousVector, Delta) == 0x00002C, "Member 'FRigUnit_DeltaFromPreviousVector::Delta' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousVector, PreviousValue) == 0x000038, "Member 'FRigUnit_DeltaFromPreviousVector::PreviousValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousVector, Cache) == 0x000044, "Member 'FRigUnit_DeltaFromPreviousVector::Cache' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_DebugBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_DebugBase) == 0x000008, "Wrong alignment on FRigUnit_DebugBase");
static_assert(sizeof(FRigUnit_DebugBase) == 0x000020, "Wrong size on FRigUnit_DebugBase");

// ScriptStruct ControlRig.RigUnit_DebugBezier
// 0x0098 (0x00D0 - 0x0038)
struct FRigUnit_DebugBezier final : public FRigUnit_DebugBaseMutable
{
public:
	struct FCRFourPointBezier                     Bezier;                                            // 0x0038(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinimumU;                                          // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumU;                                          // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Detail;                                            // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugBezier) == 0x000010, "Wrong alignment on FRigUnit_DebugBezier");
static_assert(sizeof(FRigUnit_DebugBezier) == 0x0000D0, "Wrong size on FRigUnit_DebugBezier");
static_assert(offsetof(FRigUnit_DebugBezier, Bezier) == 0x000038, "Member 'FRigUnit_DebugBezier::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, MinimumU) == 0x000068, "Member 'FRigUnit_DebugBezier::MinimumU' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, MaximumU) == 0x00006C, "Member 'FRigUnit_DebugBezier::MaximumU' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, Color) == 0x000070, "Member 'FRigUnit_DebugBezier::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, Thickness) == 0x000080, "Member 'FRigUnit_DebugBezier::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, Detail) == 0x000084, "Member 'FRigUnit_DebugBezier::Detail' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, Space) == 0x000088, "Member 'FRigUnit_DebugBezier::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, WorldOffset) == 0x000090, "Member 'FRigUnit_DebugBezier::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugBezier, bEnabled) == 0x0000C0, "Member 'FRigUnit_DebugBezier::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugHierarchy
// 0x0068 (0x00A0 - 0x0038)
struct FRigUnit_DebugHierarchy final : public FRigUnit_DebugBaseMutable
{
public:
	EControlRigDrawHierarchyMode                  Mode;                                              // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0060(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugHierarchy) == 0x000010, "Wrong alignment on FRigUnit_DebugHierarchy");
static_assert(sizeof(FRigUnit_DebugHierarchy) == 0x0000A0, "Wrong size on FRigUnit_DebugHierarchy");
static_assert(offsetof(FRigUnit_DebugHierarchy, Mode) == 0x000038, "Member 'FRigUnit_DebugHierarchy::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, Scale) == 0x00003C, "Member 'FRigUnit_DebugHierarchy::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, Color) == 0x000040, "Member 'FRigUnit_DebugHierarchy::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, Thickness) == 0x000050, "Member 'FRigUnit_DebugHierarchy::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, WorldOffset) == 0x000060, "Member 'FRigUnit_DebugHierarchy::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugHierarchy, bEnabled) == 0x000090, "Member 'FRigUnit_DebugHierarchy::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolConstant
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_MathBoolConstant : public FRigUnit_MathBoolBase
{
public:
	bool                                          Value;                                             // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolConstant) == 0x000008, "Wrong alignment on FRigUnit_MathBoolConstant");
static_assert(sizeof(FRigUnit_MathBoolConstant) == 0x000028, "Wrong size on FRigUnit_MathBoolConstant");
static_assert(offsetof(FRigUnit_MathBoolConstant, Value) == 0x000020, "Member 'FRigUnit_MathBoolConstant::Value' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolConstTrue
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathBoolConstTrue final : public FRigUnit_MathBoolConstant
{
};
static_assert(alignof(FRigUnit_MathBoolConstTrue) == 0x000008, "Wrong alignment on FRigUnit_MathBoolConstTrue");
static_assert(sizeof(FRigUnit_MathBoolConstTrue) == 0x000028, "Wrong size on FRigUnit_MathBoolConstTrue");

// ScriptStruct ControlRig.RigUnit_DebugLine
// 0x0078 (0x00B0 - 0x0038)
struct FRigUnit_DebugLine final : public FRigUnit_DebugBaseMutable
{
public:
	struct FVector                                A;                                                 // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0064(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0070(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugLine) == 0x000010, "Wrong alignment on FRigUnit_DebugLine");
static_assert(sizeof(FRigUnit_DebugLine) == 0x0000B0, "Wrong size on FRigUnit_DebugLine");
static_assert(offsetof(FRigUnit_DebugLine, A) == 0x000038, "Member 'FRigUnit_DebugLine::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, B) == 0x000044, "Member 'FRigUnit_DebugLine::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, Color) == 0x000050, "Member 'FRigUnit_DebugLine::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, Thickness) == 0x000060, "Member 'FRigUnit_DebugLine::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, Space) == 0x000064, "Member 'FRigUnit_DebugLine::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, WorldOffset) == 0x000070, "Member 'FRigUnit_DebugLine::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLine, bEnabled) == 0x0000A0, "Member 'FRigUnit_DebugLine::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugLineStrip
// 0x0078 (0x00B0 - 0x0038)
struct FRigUnit_DebugLineStrip final : public FRigUnit_DebugBaseMutable
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x005C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0070(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugLineStrip) == 0x000010, "Wrong alignment on FRigUnit_DebugLineStrip");
static_assert(sizeof(FRigUnit_DebugLineStrip) == 0x0000B0, "Wrong size on FRigUnit_DebugLineStrip");
static_assert(offsetof(FRigUnit_DebugLineStrip, Points) == 0x000038, "Member 'FRigUnit_DebugLineStrip::Points' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, Color) == 0x000048, "Member 'FRigUnit_DebugLineStrip::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, Thickness) == 0x000058, "Member 'FRigUnit_DebugLineStrip::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, Space) == 0x00005C, "Member 'FRigUnit_DebugLineStrip::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, WorldOffset) == 0x000070, "Member 'FRigUnit_DebugLineStrip::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugLineStrip, bEnabled) == 0x0000A0, "Member 'FRigUnit_DebugLineStrip::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugPointMutable
// 0x0078 (0x00B0 - 0x0038)
struct FRigUnit_DebugPointMutable final : public FRigUnit_DebugBaseMutable
{
public:
	struct FVector                                Vector;                                            // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigUnitDebugPointMode                        Mode;                                              // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0070(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugPointMutable) == 0x000010, "Wrong alignment on FRigUnit_DebugPointMutable");
static_assert(sizeof(FRigUnit_DebugPointMutable) == 0x0000B0, "Wrong size on FRigUnit_DebugPointMutable");
static_assert(offsetof(FRigUnit_DebugPointMutable, Vector) == 0x000038, "Member 'FRigUnit_DebugPointMutable::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Mode) == 0x000044, "Member 'FRigUnit_DebugPointMutable::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Color) == 0x000048, "Member 'FRigUnit_DebugPointMutable::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Scale) == 0x000058, "Member 'FRigUnit_DebugPointMutable::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Thickness) == 0x00005C, "Member 'FRigUnit_DebugPointMutable::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, Space) == 0x000060, "Member 'FRigUnit_DebugPointMutable::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, WorldOffset) == 0x000070, "Member 'FRigUnit_DebugPointMutable::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPointMutable, bEnabled) == 0x0000A0, "Member 'FRigUnit_DebugPointMutable::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugPoint
// 0x0070 (0x0090 - 0x0020)
struct FRigUnit_DebugPoint final : public FRigUnit_DebugBase
{
public:
	struct FVector                                Vector;                                            // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigUnitDebugPointMode                        Mode;                                              // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0xF];                                       // 0x0081(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugPoint) == 0x000010, "Wrong alignment on FRigUnit_DebugPoint");
static_assert(sizeof(FRigUnit_DebugPoint) == 0x000090, "Wrong size on FRigUnit_DebugPoint");
static_assert(offsetof(FRigUnit_DebugPoint, Vector) == 0x000020, "Member 'FRigUnit_DebugPoint::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Mode) == 0x00002C, "Member 'FRigUnit_DebugPoint::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Color) == 0x000030, "Member 'FRigUnit_DebugPoint::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Scale) == 0x000040, "Member 'FRigUnit_DebugPoint::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Thickness) == 0x000044, "Member 'FRigUnit_DebugPoint::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, Space) == 0x000048, "Member 'FRigUnit_DebugPoint::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, WorldOffset) == 0x000050, "Member 'FRigUnit_DebugPoint::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugPoint, bEnabled) == 0x000080, "Member 'FRigUnit_DebugPoint::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_EndProfilingTimer
// 0x0020 (0x0058 - 0x0038)
struct FRigUnit_EndProfilingTimer final : public FRigUnit_DebugBaseMutable
{
public:
	int32                                         NumberOfMeasurements;                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Prefix;                                            // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedTime;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeasurementsLeft;                                  // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_EndProfilingTimer) == 0x000008, "Wrong alignment on FRigUnit_EndProfilingTimer");
static_assert(sizeof(FRigUnit_EndProfilingTimer) == 0x000058, "Wrong size on FRigUnit_EndProfilingTimer");
static_assert(offsetof(FRigUnit_EndProfilingTimer, NumberOfMeasurements) == 0x000038, "Member 'FRigUnit_EndProfilingTimer::NumberOfMeasurements' has a wrong offset!");
static_assert(offsetof(FRigUnit_EndProfilingTimer, Prefix) == 0x000040, "Member 'FRigUnit_EndProfilingTimer::Prefix' has a wrong offset!");
static_assert(offsetof(FRigUnit_EndProfilingTimer, AccumulatedTime) == 0x000050, "Member 'FRigUnit_EndProfilingTimer::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_EndProfilingTimer, MeasurementsLeft) == 0x000054, "Member 'FRigUnit_EndProfilingTimer::MeasurementsLeft' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugArc
// 0x00A8 (0x00E0 - 0x0038)
struct FRigUnit_DebugArc final : public FRigUnit_DebugBaseMutable
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDegrees;                                    // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDegrees;                                    // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Detail;                                            // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0094(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x00A0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0xF];                                       // 0x00D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugArc) == 0x000010, "Wrong alignment on FRigUnit_DebugArc");
static_assert(sizeof(FRigUnit_DebugArc) == 0x0000E0, "Wrong size on FRigUnit_DebugArc");
static_assert(offsetof(FRigUnit_DebugArc, Transform) == 0x000040, "Member 'FRigUnit_DebugArc::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Color) == 0x000070, "Member 'FRigUnit_DebugArc::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Radius) == 0x000080, "Member 'FRigUnit_DebugArc::Radius' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, MinimumDegrees) == 0x000084, "Member 'FRigUnit_DebugArc::MinimumDegrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, MaximumDegrees) == 0x000088, "Member 'FRigUnit_DebugArc::MaximumDegrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Thickness) == 0x00008C, "Member 'FRigUnit_DebugArc::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Detail) == 0x000090, "Member 'FRigUnit_DebugArc::Detail' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, Space) == 0x000094, "Member 'FRigUnit_DebugArc::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, WorldOffset) == 0x0000A0, "Member 'FRigUnit_DebugArc::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugArc, bEnabled) == 0x0000D0, "Member 'FRigUnit_DebugArc::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugRectangle
// 0x0098 (0x00D0 - 0x0038)
struct FRigUnit_DebugRectangle final : public FRigUnit_DebugBaseMutable
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldOffset;                                       // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugRectangle) == 0x000010, "Wrong alignment on FRigUnit_DebugRectangle");
static_assert(sizeof(FRigUnit_DebugRectangle) == 0x0000D0, "Wrong size on FRigUnit_DebugRectangle");
static_assert(offsetof(FRigUnit_DebugRectangle, Transform) == 0x000040, "Member 'FRigUnit_DebugRectangle::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, Color) == 0x000070, "Member 'FRigUnit_DebugRectangle::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, Scale) == 0x000080, "Member 'FRigUnit_DebugRectangle::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, Thickness) == 0x000084, "Member 'FRigUnit_DebugRectangle::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, Space) == 0x000088, "Member 'FRigUnit_DebugRectangle::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, WorldOffset) == 0x000090, "Member 'FRigUnit_DebugRectangle::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugRectangle, bEnabled) == 0x0000C0, "Member 'FRigUnit_DebugRectangle::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugTransformMutable
// 0x00A8 (0x00E0 - 0x0038)
struct FRigUnit_DebugTransformMutable final : public FRigUnit_DebugBaseMutable
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ERigUnitDebugTransformMode                    Mode;                                              // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0074(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x008C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x00A0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0xF];                                       // 0x00D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugTransformMutable) == 0x000010, "Wrong alignment on FRigUnit_DebugTransformMutable");
static_assert(sizeof(FRigUnit_DebugTransformMutable) == 0x0000E0, "Wrong size on FRigUnit_DebugTransformMutable");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Transform) == 0x000040, "Member 'FRigUnit_DebugTransformMutable::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Mode) == 0x000070, "Member 'FRigUnit_DebugTransformMutable::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Color) == 0x000074, "Member 'FRigUnit_DebugTransformMutable::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Thickness) == 0x000084, "Member 'FRigUnit_DebugTransformMutable::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Scale) == 0x000088, "Member 'FRigUnit_DebugTransformMutable::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, Space) == 0x00008C, "Member 'FRigUnit_DebugTransformMutable::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, WorldOffset) == 0x0000A0, "Member 'FRigUnit_DebugTransformMutable::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransformMutable, bEnabled) == 0x0000D0, "Member 'FRigUnit_DebugTransformMutable::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DebugTransform
// 0x00A0 (0x00C0 - 0x0020)
struct FRigUnit_DebugTransform final : public FRigUnit_DebugBase
{
public:
	struct FTransform                             Transform;                                         // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ERigUnitDebugTransformMode                    Mode;                                              // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0054(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x006C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0080(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_DebugTransform) == 0x000010, "Wrong alignment on FRigUnit_DebugTransform");
static_assert(sizeof(FRigUnit_DebugTransform) == 0x0000C0, "Wrong size on FRigUnit_DebugTransform");
static_assert(offsetof(FRigUnit_DebugTransform, Transform) == 0x000020, "Member 'FRigUnit_DebugTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Mode) == 0x000050, "Member 'FRigUnit_DebugTransform::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Color) == 0x000054, "Member 'FRigUnit_DebugTransform::Color' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Thickness) == 0x000064, "Member 'FRigUnit_DebugTransform::Thickness' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Scale) == 0x000068, "Member 'FRigUnit_DebugTransform::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, Space) == 0x00006C, "Member 'FRigUnit_DebugTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, WorldOffset) == 0x000080, "Member 'FRigUnit_DebugTransform::WorldOffset' has a wrong offset!");
static_assert(offsetof(FRigUnit_DebugTransform, bEnabled) == 0x0000B0, "Member 'FRigUnit_DebugTransform::bEnabled' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DeltaFromPreviousTransform
// 0x00C0 (0x00E0 - 0x0020)
struct FRigUnit_DeltaFromPreviousTransform final : public FRigUnit_SimBase
{
public:
	struct FTransform                             Value;                                             // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Delta;                                             // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             PreviousValue;                                     // 0x0080(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Cache;                                             // 0x00B0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DeltaFromPreviousTransform) == 0x000010, "Wrong alignment on FRigUnit_DeltaFromPreviousTransform");
static_assert(sizeof(FRigUnit_DeltaFromPreviousTransform) == 0x0000E0, "Wrong size on FRigUnit_DeltaFromPreviousTransform");
static_assert(offsetof(FRigUnit_DeltaFromPreviousTransform, Value) == 0x000020, "Member 'FRigUnit_DeltaFromPreviousTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousTransform, Delta) == 0x000050, "Member 'FRigUnit_DeltaFromPreviousTransform::Delta' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousTransform, PreviousValue) == 0x000080, "Member 'FRigUnit_DeltaFromPreviousTransform::PreviousValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousTransform, Cache) == 0x0000B0, "Member 'FRigUnit_DeltaFromPreviousTransform::Cache' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DeltaFromPreviousQuat
// 0x0040 (0x0060 - 0x0020)
struct FRigUnit_DeltaFromPreviousQuat final : public FRigUnit_SimBase
{
public:
	struct FQuat                                  Value;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Delta;                                             // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  PreviousValue;                                     // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Cache;                                             // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DeltaFromPreviousQuat) == 0x000010, "Wrong alignment on FRigUnit_DeltaFromPreviousQuat");
static_assert(sizeof(FRigUnit_DeltaFromPreviousQuat) == 0x000060, "Wrong size on FRigUnit_DeltaFromPreviousQuat");
static_assert(offsetof(FRigUnit_DeltaFromPreviousQuat, Value) == 0x000020, "Member 'FRigUnit_DeltaFromPreviousQuat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousQuat, Delta) == 0x000030, "Member 'FRigUnit_DeltaFromPreviousQuat::Delta' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousQuat, PreviousValue) == 0x000040, "Member 'FRigUnit_DeltaFromPreviousQuat::PreviousValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousQuat, Cache) == 0x000050, "Member 'FRigUnit_DeltaFromPreviousQuat::Cache' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DeltaFromPreviousFloat
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_DeltaFromPreviousFloat final : public FRigUnit_SimBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delta;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousValue;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cache;                                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DeltaFromPreviousFloat) == 0x000008, "Wrong alignment on FRigUnit_DeltaFromPreviousFloat");
static_assert(sizeof(FRigUnit_DeltaFromPreviousFloat) == 0x000030, "Wrong size on FRigUnit_DeltaFromPreviousFloat");
static_assert(offsetof(FRigUnit_DeltaFromPreviousFloat, Value) == 0x000020, "Member 'FRigUnit_DeltaFromPreviousFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousFloat, Delta) == 0x000024, "Member 'FRigUnit_DeltaFromPreviousFloat::Delta' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousFloat, PreviousValue) == 0x000028, "Member 'FRigUnit_DeltaFromPreviousFloat::PreviousValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_DeltaFromPreviousFloat, Cache) == 0x00002C, "Member 'FRigUnit_DeltaFromPreviousFloat::Cache' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_DistributeRotation
// 0x0078 (0x00B0 - 0x0038)
struct FRigUnit_DistributeRotation final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBone;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRigUnit_DistributeRotation_Rotation> Rotations;                                         // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     RotationEaseType;                                  // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 BoneIndices;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BoneRotationA;                                     // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BoneRotationB;                                     // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BoneRotationT;                                     // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     BoneLocalTransforms;                               // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_DistributeRotation) == 0x000008, "Wrong alignment on FRigUnit_DistributeRotation");
static_assert(sizeof(FRigUnit_DistributeRotation) == 0x0000B0, "Wrong size on FRigUnit_DistributeRotation");
static_assert(offsetof(FRigUnit_DistributeRotation, StartBone) == 0x000038, "Member 'FRigUnit_DistributeRotation::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, EndBone) == 0x000040, "Member 'FRigUnit_DistributeRotation::EndBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, Rotations) == 0x000048, "Member 'FRigUnit_DistributeRotation::Rotations' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, RotationEaseType) == 0x000058, "Member 'FRigUnit_DistributeRotation::RotationEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, bPropagateToChildren) == 0x000059, "Member 'FRigUnit_DistributeRotation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, BoneIndices) == 0x000060, "Member 'FRigUnit_DistributeRotation::BoneIndices' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, BoneRotationA) == 0x000070, "Member 'FRigUnit_DistributeRotation::BoneRotationA' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, BoneRotationB) == 0x000080, "Member 'FRigUnit_DistributeRotation::BoneRotationB' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, BoneRotationT) == 0x000090, "Member 'FRigUnit_DistributeRotation::BoneRotationT' has a wrong offset!");
static_assert(offsetof(FRigUnit_DistributeRotation, BoneLocalTransforms) == 0x0000A0, "Member 'FRigUnit_DistributeRotation::BoneLocalTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformBinaryOp
// 0x0090 (0x00B0 - 0x0020)
struct FRigUnit_MathTransformBinaryOp : public FRigUnit_MathTransformBase
{
public:
	struct FTransform                             A;                                                 // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0080(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformBinaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathTransformBinaryOp");
static_assert(sizeof(FRigUnit_MathTransformBinaryOp) == 0x0000B0, "Wrong size on FRigUnit_MathTransformBinaryOp");
static_assert(offsetof(FRigUnit_MathTransformBinaryOp, A) == 0x000020, "Member 'FRigUnit_MathTransformBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformBinaryOp, B) == 0x000050, "Member 'FRigUnit_MathTransformBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformBinaryOp, Result) == 0x000080, "Member 'FRigUnit_MathTransformBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformMul
// 0x0000 (0x00B0 - 0x00B0)
struct FRigUnit_MathTransformMul final : public FRigUnit_MathTransformBinaryOp
{
};
static_assert(alignof(FRigUnit_MathTransformMul) == 0x000010, "Wrong alignment on FRigUnit_MathTransformMul");
static_assert(sizeof(FRigUnit_MathTransformMul) == 0x0000B0, "Wrong size on FRigUnit_MathTransformMul");

// ScriptStruct ControlRig.StructReference
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FStructReference
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStructReference) == 0x000008, "Wrong alignment on FStructReference");
static_assert(sizeof(FStructReference) == 0x000008, "Wrong size on FStructReference");

// ScriptStruct ControlRig.RigUnitReference_Example
// 0x0000 (0x0008 - 0x0008)
struct FRigUnitReference_Example final : public FStructReference
{
};
static_assert(alignof(FRigUnitReference_Example) == 0x000008, "Wrong alignment on FRigUnitReference_Example");
static_assert(sizeof(FRigUnitReference_Example) == 0x000008, "Wrong size on FRigUnitReference_Example");

// ScriptStruct ControlRig.RigUnit_Example
// 0x0098 (0x00D0 - 0x0038)
struct FRigUnit_Example final : public FRigUnitMutable
{
public:
	class FString                                 TestInputString;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEulerTransform                        TestInOutTransform;                                // 0x0048(0x0024)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TestInputVector;                                   // 0x006C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TestInputInteger;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                TestInputObject;                                   // 0x0080(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestOutputVector;                                  // 0x0088(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestInputFloat;                                    // 0x0094(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 TestInputFloatArray;                               // 0x0098(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     TestInputTransformArray;                           // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         TestOutputFloat;                                   // 0x00B8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnitReference_Example              TestUnitReferenceInput;                            // 0x00C0(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigUnitReference_Example              TestUnitReferenceOutput;                           // 0x00C8(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_Example) == 0x000008, "Wrong alignment on FRigUnit_Example");
static_assert(sizeof(FRigUnit_Example) == 0x0000D0, "Wrong size on FRigUnit_Example");
static_assert(offsetof(FRigUnit_Example, TestInputString) == 0x000038, "Member 'FRigUnit_Example::TestInputString' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInOutTransform) == 0x000048, "Member 'FRigUnit_Example::TestInOutTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputVector) == 0x00006C, "Member 'FRigUnit_Example::TestInputVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputInteger) == 0x000078, "Member 'FRigUnit_Example::TestInputInteger' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputObject) == 0x000080, "Member 'FRigUnit_Example::TestInputObject' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestOutputVector) == 0x000088, "Member 'FRigUnit_Example::TestOutputVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputFloat) == 0x000094, "Member 'FRigUnit_Example::TestInputFloat' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputFloatArray) == 0x000098, "Member 'FRigUnit_Example::TestInputFloatArray' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestInputTransformArray) == 0x0000A8, "Member 'FRigUnit_Example::TestInputTransformArray' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestOutputFloat) == 0x0000B8, "Member 'FRigUnit_Example::TestOutputFloat' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestUnitReferenceInput) == 0x0000C0, "Member 'FRigUnit_Example::TestUnitReferenceInput' has a wrong offset!");
static_assert(offsetof(FRigUnit_Example, TestUnitReferenceOutput) == 0x0000C8, "Member 'FRigUnit_Example::TestUnitReferenceOutput' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FABRIK
// 0x0088 (0x00C0 - 0x0038)
struct FRigUnit_FABRIK final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectorBone;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EffectorTransform;                                 // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxIterations;                                     // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x34];                                      // 0x008C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FABRIK) == 0x000010, "Wrong alignment on FRigUnit_FABRIK");
static_assert(sizeof(FRigUnit_FABRIK) == 0x0000C0, "Wrong size on FRigUnit_FABRIK");
static_assert(offsetof(FRigUnit_FABRIK, StartBone) == 0x000038, "Member 'FRigUnit_FABRIK::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, EffectorBone) == 0x000040, "Member 'FRigUnit_FABRIK::EffectorBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, EffectorTransform) == 0x000050, "Member 'FRigUnit_FABRIK::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, Precision) == 0x000080, "Member 'FRigUnit_FABRIK::Precision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, bPropagateToChildren) == 0x000084, "Member 'FRigUnit_FABRIK::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_FABRIK, MaxIterations) == 0x000088, "Member 'FRigUnit_FABRIK::MaxIterations' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurve_Rotation
// 0x0020 (0x0020 - 0x0000)
struct FRigUnit_FitChainToCurve_Rotation final
{
public:
	struct FQuat                                  Rotation;                                          // 0x0000(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FitChainToCurve_Rotation) == 0x000010, "Wrong alignment on FRigUnit_FitChainToCurve_Rotation");
static_assert(sizeof(FRigUnit_FitChainToCurve_Rotation) == 0x000020, "Wrong size on FRigUnit_FitChainToCurve_Rotation");
static_assert(offsetof(FRigUnit_FitChainToCurve_Rotation, Rotation) == 0x000000, "Member 'FRigUnit_FitChainToCurve_Rotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve_Rotation, Ratio) == 0x000010, "Member 'FRigUnit_FitChainToCurve_Rotation::Ratio' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_FitChainToCurve
// 0x0198 (0x01D0 - 0x0038)
struct FRigUnit_FitChainToCurve final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBone;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCRFourPointBezier                     Bezier;                                            // 0x0048(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	EControlRigCurveAlignment                     Alignment;                                         // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Minimum;                                           // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SamplingPrecision;                                 // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x0088(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0094(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleVectorPosition;                                // 0x00A0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnit_FitChainToCurve_Rotation> Rotations;                                         // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     RotationEaseType;                                  // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0xE];                                       // 0x00C2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_FitChainToCurve_DebugSettings DebugSettings;                                     // 0x00D0(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ChainLength;                                       // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        BonePositions;                                     // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BoneSegments;                                      // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        CurvePositions;                                    // 0x0158(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 CurveSegments;                                     // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BoneIndices;                                       // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BoneRotationA;                                     // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BoneRotationB;                                     // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BoneRotationT;                                     // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     BoneLocalTransforms;                               // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FitChainToCurve) == 0x000010, "Wrong alignment on FRigUnit_FitChainToCurve");
static_assert(sizeof(FRigUnit_FitChainToCurve) == 0x0001D0, "Wrong size on FRigUnit_FitChainToCurve");
static_assert(offsetof(FRigUnit_FitChainToCurve, StartBone) == 0x000038, "Member 'FRigUnit_FitChainToCurve::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, EndBone) == 0x000040, "Member 'FRigUnit_FitChainToCurve::EndBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Bezier) == 0x000048, "Member 'FRigUnit_FitChainToCurve::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Alignment) == 0x000078, "Member 'FRigUnit_FitChainToCurve::Alignment' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Minimum) == 0x00007C, "Member 'FRigUnit_FitChainToCurve::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Maximum) == 0x000080, "Member 'FRigUnit_FitChainToCurve::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, SamplingPrecision) == 0x000084, "Member 'FRigUnit_FitChainToCurve::SamplingPrecision' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, PrimaryAxis) == 0x000088, "Member 'FRigUnit_FitChainToCurve::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, SecondaryAxis) == 0x000094, "Member 'FRigUnit_FitChainToCurve::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, PoleVectorPosition) == 0x0000A0, "Member 'FRigUnit_FitChainToCurve::PoleVectorPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, Rotations) == 0x0000B0, "Member 'FRigUnit_FitChainToCurve::Rotations' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, RotationEaseType) == 0x0000C0, "Member 'FRigUnit_FitChainToCurve::RotationEaseType' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, bPropagateToChildren) == 0x0000C1, "Member 'FRigUnit_FitChainToCurve::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, DebugSettings) == 0x0000D0, "Member 'FRigUnit_FitChainToCurve::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, ChainLength) == 0x000130, "Member 'FRigUnit_FitChainToCurve::ChainLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, BonePositions) == 0x000138, "Member 'FRigUnit_FitChainToCurve::BonePositions' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, BoneSegments) == 0x000148, "Member 'FRigUnit_FitChainToCurve::BoneSegments' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, CurvePositions) == 0x000158, "Member 'FRigUnit_FitChainToCurve::CurvePositions' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, CurveSegments) == 0x000168, "Member 'FRigUnit_FitChainToCurve::CurveSegments' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, BoneIndices) == 0x000178, "Member 'FRigUnit_FitChainToCurve::BoneIndices' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, BoneRotationA) == 0x000188, "Member 'FRigUnit_FitChainToCurve::BoneRotationA' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, BoneRotationB) == 0x000198, "Member 'FRigUnit_FitChainToCurve::BoneRotationB' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, BoneRotationT) == 0x0001A8, "Member 'FRigUnit_FitChainToCurve::BoneRotationT' has a wrong offset!");
static_assert(offsetof(FRigUnit_FitChainToCurve, BoneLocalTransforms) == 0x0001B8, "Member 'FRigUnit_FitChainToCurve::BoneLocalTransforms' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorSelectBool
// 0x0028 (0x0048 - 0x0020)
struct FRigUnit_MathVectorSelectBool final : public FRigUnit_MathVectorBase
{
public:
	bool                                          Condition;                                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IfTrue;                                            // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IfFalse;                                           // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorSelectBool) == 0x000008, "Wrong alignment on FRigUnit_MathVectorSelectBool");
static_assert(sizeof(FRigUnit_MathVectorSelectBool) == 0x000048, "Wrong size on FRigUnit_MathVectorSelectBool");
static_assert(offsetof(FRigUnit_MathVectorSelectBool, Condition) == 0x000020, "Member 'FRigUnit_MathVectorSelectBool::Condition' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorSelectBool, IfTrue) == 0x000024, "Member 'FRigUnit_MathVectorSelectBool::IfTrue' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorSelectBool, IfFalse) == 0x000030, "Member 'FRigUnit_MathVectorSelectBool::IfFalse' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorSelectBool, Result) == 0x00003C, "Member 'FRigUnit_MathVectorSelectBool::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorRemap
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_MathVectorRemap final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceMinimum;                                     // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceMaximum;                                     // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetMinimum;                                     // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetMaximum;                                     // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClamp;                                            // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0060(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorRemap) == 0x000008, "Wrong alignment on FRigUnit_MathVectorRemap");
static_assert(sizeof(FRigUnit_MathVectorRemap) == 0x000070, "Wrong size on FRigUnit_MathVectorRemap");
static_assert(offsetof(FRigUnit_MathVectorRemap, Value) == 0x000020, "Member 'FRigUnit_MathVectorRemap::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, SourceMinimum) == 0x00002C, "Member 'FRigUnit_MathVectorRemap::SourceMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, SourceMaximum) == 0x000038, "Member 'FRigUnit_MathVectorRemap::SourceMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, TargetMinimum) == 0x000044, "Member 'FRigUnit_MathVectorRemap::TargetMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, TargetMaximum) == 0x000050, "Member 'FRigUnit_MathVectorRemap::TargetMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, bClamp) == 0x00005C, "Member 'FRigUnit_MathVectorRemap::bClamp' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorRemap, Result) == 0x000060, "Member 'FRigUnit_MathVectorRemap::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MapRange_Float
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_MapRange_Float final : public FRigUnit
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinIn;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIn;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOut;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOut;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MapRange_Float) == 0x000008, "Wrong alignment on FRigUnit_MapRange_Float");
static_assert(sizeof(FRigUnit_MapRange_Float) == 0x000038, "Wrong size on FRigUnit_MapRange_Float");
static_assert(offsetof(FRigUnit_MapRange_Float, Value) == 0x000020, "Member 'FRigUnit_MapRange_Float::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, MinIn) == 0x000024, "Member 'FRigUnit_MapRange_Float::MinIn' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, MaxIn) == 0x000028, "Member 'FRigUnit_MapRange_Float::MaxIn' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, MinOut) == 0x00002C, "Member 'FRigUnit_MapRange_Float::MinOut' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, MaxOut) == 0x000030, "Member 'FRigUnit_MapRange_Float::MaxOut' has a wrong offset!");
static_assert(offsetof(FRigUnit_MapRange_Float, Result) == 0x000034, "Member 'FRigUnit_MapRange_Float::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Clamp_Float
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_Clamp_Float final : public FRigUnit
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_Clamp_Float) == 0x000008, "Wrong alignment on FRigUnit_Clamp_Float");
static_assert(sizeof(FRigUnit_Clamp_Float) == 0x000030, "Wrong size on FRigUnit_Clamp_Float");
static_assert(offsetof(FRigUnit_Clamp_Float, Value) == 0x000020, "Member 'FRigUnit_Clamp_Float::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Min) == 0x000024, "Member 'FRigUnit_Clamp_Float::Min' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Max) == 0x000028, "Member 'FRigUnit_Clamp_Float::Max' has a wrong offset!");
static_assert(offsetof(FRigUnit_Clamp_Float, Result) == 0x00002C, "Member 'FRigUnit_Clamp_Float::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorEquals
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorEquals final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorEquals) == 0x000008, "Wrong alignment on FRigUnit_MathVectorEquals");
static_assert(sizeof(FRigUnit_MathVectorEquals) == 0x000040, "Wrong size on FRigUnit_MathVectorEquals");
static_assert(offsetof(FRigUnit_MathVectorEquals, A) == 0x000020, "Member 'FRigUnit_MathVectorEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorEquals, B) == 0x00002C, "Member 'FRigUnit_MathVectorEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorEquals, Result) == 0x000038, "Member 'FRigUnit_MathVectorEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Divide_FloatFloat
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_Divide_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Divide_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Divide_FloatFloat");
static_assert(sizeof(FRigUnit_Divide_FloatFloat) == 0x000030, "Wrong size on FRigUnit_Divide_FloatFloat");

// ScriptStruct ControlRig.RigUnit_MathFloatConstTwoPi
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatConstTwoPi final : public FRigUnit_MathFloatConstant
{
};
static_assert(alignof(FRigUnit_MathFloatConstTwoPi) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstTwoPi");
static_assert(sizeof(FRigUnit_MathFloatConstTwoPi) == 0x000028, "Wrong size on FRigUnit_MathFloatConstTwoPi");

// ScriptStruct ControlRig.RigUnit_Subtract_FloatFloat
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_Subtract_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Subtract_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Subtract_FloatFloat");
static_assert(sizeof(FRigUnit_Subtract_FloatFloat) == 0x000030, "Wrong size on FRigUnit_Subtract_FloatFloat");

// ScriptStruct ControlRig.RigUnit_Multiply_FloatFloat
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_Multiply_FloatFloat final : public FRigUnit_BinaryFloatOp
{
};
static_assert(alignof(FRigUnit_Multiply_FloatFloat) == 0x000008, "Wrong alignment on FRigUnit_Multiply_FloatFloat");
static_assert(sizeof(FRigUnit_Multiply_FloatFloat) == 0x000030, "Wrong size on FRigUnit_Multiply_FloatFloat");

// ScriptStruct ControlRig.RigUnit_Divide_VectorVector
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_Divide_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Divide_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Divide_VectorVector");
static_assert(sizeof(FRigUnit_Divide_VectorVector) == 0x000048, "Wrong size on FRigUnit_Divide_VectorVector");

// ScriptStruct ControlRig.RigUnit_GetBoneTransform
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_GetBoneTransform final : public FRigUnit
{
public:
	class FName                                   Bone;                                              // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0030(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CachedBoneIndex;                                   // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_GetBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_GetBoneTransform");
static_assert(sizeof(FRigUnit_GetBoneTransform) == 0x000070, "Wrong size on FRigUnit_GetBoneTransform");
static_assert(offsetof(FRigUnit_GetBoneTransform, Bone) == 0x000020, "Member 'FRigUnit_GetBoneTransform::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetBoneTransform, Space) == 0x000028, "Member 'FRigUnit_GetBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetBoneTransform, Transform) == 0x000030, "Member 'FRigUnit_GetBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetBoneTransform, CachedBoneIndex) == 0x000060, "Member 'FRigUnit_GetBoneTransform::CachedBoneIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetDeltaTime
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_GetDeltaTime final : public FRigUnit_AnimBase
{
public:
	float                                         Result;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_GetDeltaTime) == 0x000008, "Wrong alignment on FRigUnit_GetDeltaTime");
static_assert(sizeof(FRigUnit_GetDeltaTime) == 0x000028, "Wrong size on FRigUnit_GetDeltaTime");
static_assert(offsetof(FRigUnit_GetDeltaTime, Result) == 0x000020, "Member 'FRigUnit_GetDeltaTime::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetJointTransform
// 0x0088 (0x00C0 - 0x0038)
struct FRigUnit_GetJointTransform final : public FRigUnitMutable
{
public:
	class FName                                   Joint;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformGetterType                          Type;                                              // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           TransformSpace;                                    // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseJoint;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Output;                                            // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetJointTransform) == 0x000010, "Wrong alignment on FRigUnit_GetJointTransform");
static_assert(sizeof(FRigUnit_GetJointTransform) == 0x0000C0, "Wrong size on FRigUnit_GetJointTransform");
static_assert(offsetof(FRigUnit_GetJointTransform, Joint) == 0x000038, "Member 'FRigUnit_GetJointTransform::Joint' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, Type) == 0x000040, "Member 'FRigUnit_GetJointTransform::Type' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, TransformSpace) == 0x000041, "Member 'FRigUnit_GetJointTransform::TransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, BaseTransform) == 0x000050, "Member 'FRigUnit_GetJointTransform::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, BaseJoint) == 0x000080, "Member 'FRigUnit_GetJointTransform::BaseJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetJointTransform, Output) == 0x000090, "Member 'FRigUnit_GetJointTransform::Output' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetRelativeBoneTransform
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_GetRelativeBoneTransform final : public FRigUnit
{
public:
	class FName                                   Bone;                                              // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Space;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0030(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CachedBoneIndex;                                   // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedSpaceIndex;                                  // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_GetRelativeBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_GetRelativeBoneTransform");
static_assert(sizeof(FRigUnit_GetRelativeBoneTransform) == 0x000070, "Wrong size on FRigUnit_GetRelativeBoneTransform");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, Bone) == 0x000020, "Member 'FRigUnit_GetRelativeBoneTransform::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, Space) == 0x000028, "Member 'FRigUnit_GetRelativeBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, Transform) == 0x000030, "Member 'FRigUnit_GetRelativeBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, CachedBoneIndex) == 0x000060, "Member 'FRigUnit_GetRelativeBoneTransform::CachedBoneIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetRelativeBoneTransform, CachedSpaceIndex) == 0x000064, "Member 'FRigUnit_GetRelativeBoneTransform::CachedSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetWorldTime
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_GetWorldTime final : public FRigUnit_AnimBase
{
public:
	float                                         Year;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Month;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Day;                                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeekDay;                                           // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hours;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minutes;                                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Seconds;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverallSeconds;                                    // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetWorldTime) == 0x000008, "Wrong alignment on FRigUnit_GetWorldTime");
static_assert(sizeof(FRigUnit_GetWorldTime) == 0x000040, "Wrong size on FRigUnit_GetWorldTime");
static_assert(offsetof(FRigUnit_GetWorldTime, Year) == 0x000020, "Member 'FRigUnit_GetWorldTime::Year' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Month) == 0x000024, "Member 'FRigUnit_GetWorldTime::Month' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Day) == 0x000028, "Member 'FRigUnit_GetWorldTime::Day' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, WeekDay) == 0x00002C, "Member 'FRigUnit_GetWorldTime::WeekDay' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Hours) == 0x000030, "Member 'FRigUnit_GetWorldTime::Hours' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Minutes) == 0x000034, "Member 'FRigUnit_GetWorldTime::Minutes' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, Seconds) == 0x000038, "Member 'FRigUnit_GetWorldTime::Seconds' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetWorldTime, OverallSeconds) == 0x00003C, "Member 'FRigUnit_GetWorldTime::OverallSeconds' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Add_VectorVector
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_Add_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Add_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Add_VectorVector");
static_assert(sizeof(FRigUnit_Add_VectorVector) == 0x000048, "Wrong size on FRigUnit_Add_VectorVector");

// ScriptStruct ControlRig.RigUnit_HighlevelBase
// 0x0000 (0x0020 - 0x0020)
struct FRigUnit_HighlevelBase final : public FRigUnit
{
};
static_assert(alignof(FRigUnit_HighlevelBase) == 0x000008, "Wrong alignment on FRigUnit_HighlevelBase");
static_assert(sizeof(FRigUnit_HighlevelBase) == 0x000020, "Wrong size on FRigUnit_HighlevelBase");

// ScriptStruct ControlRig.RigUnit_MathFloatBinaryOp
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatBinaryOp : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatBinaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathFloatBinaryOp");
static_assert(sizeof(FRigUnit_MathFloatBinaryOp) == 0x000030, "Wrong size on FRigUnit_MathFloatBinaryOp");
static_assert(offsetof(FRigUnit_MathFloatBinaryOp, A) == 0x000020, "Member 'FRigUnit_MathFloatBinaryOp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatBinaryOp, B) == 0x000024, "Member 'FRigUnit_MathFloatBinaryOp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatBinaryOp, Result) == 0x000028, "Member 'FRigUnit_MathFloatBinaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_KalmanTransform
// 0x0090 (0x00B0 - 0x0020)
struct FRigUnit_KalmanTransform final : public FRigUnit_SimBase
{
public:
	struct FTransform                             Value;                                             // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0060(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Buffer;                                            // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_KalmanTransform) == 0x000010, "Wrong alignment on FRigUnit_KalmanTransform");
static_assert(sizeof(FRigUnit_KalmanTransform) == 0x0000B0, "Wrong size on FRigUnit_KalmanTransform");
static_assert(offsetof(FRigUnit_KalmanTransform, Value) == 0x000020, "Member 'FRigUnit_KalmanTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanTransform, BufferSize) == 0x000050, "Member 'FRigUnit_KalmanTransform::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanTransform, Result) == 0x000060, "Member 'FRigUnit_KalmanTransform::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanTransform, Buffer) == 0x000090, "Member 'FRigUnit_KalmanTransform::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanTransform, LastInsertIndex) == 0x0000A0, "Member 'FRigUnit_KalmanTransform::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_KalmanVector
// 0x0038 (0x0058 - 0x0020)
struct FRigUnit_KalmanVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Buffer;                                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_KalmanVector) == 0x000008, "Wrong alignment on FRigUnit_KalmanVector");
static_assert(sizeof(FRigUnit_KalmanVector) == 0x000058, "Wrong size on FRigUnit_KalmanVector");
static_assert(offsetof(FRigUnit_KalmanVector, Value) == 0x000020, "Member 'FRigUnit_KalmanVector::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanVector, BufferSize) == 0x00002C, "Member 'FRigUnit_KalmanVector::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanVector, Result) == 0x000030, "Member 'FRigUnit_KalmanVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanVector, Buffer) == 0x000040, "Member 'FRigUnit_KalmanVector::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanVector, LastInsertIndex) == 0x000050, "Member 'FRigUnit_KalmanVector::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatMin
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_MathFloatMin final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatMin) == 0x000008, "Wrong alignment on FRigUnit_MathFloatMin");
static_assert(sizeof(FRigUnit_MathFloatMin) == 0x000030, "Wrong size on FRigUnit_MathFloatMin");

// ScriptStruct ControlRig.RigUnit_KalmanFloat
// 0x0028 (0x0048 - 0x0020)
struct FRigUnit_KalmanFloat final : public FRigUnit_SimBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Buffer;                                            // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_KalmanFloat) == 0x000008, "Wrong alignment on FRigUnit_KalmanFloat");
static_assert(sizeof(FRigUnit_KalmanFloat) == 0x000048, "Wrong size on FRigUnit_KalmanFloat");
static_assert(offsetof(FRigUnit_KalmanFloat, Value) == 0x000020, "Member 'FRigUnit_KalmanFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanFloat, BufferSize) == 0x000024, "Member 'FRigUnit_KalmanFloat::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanFloat, Result) == 0x000028, "Member 'FRigUnit_KalmanFloat::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanFloat, Buffer) == 0x000030, "Member 'FRigUnit_KalmanFloat::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_KalmanFloat, LastInsertIndex) == 0x000040, "Member 'FRigUnit_KalmanFloat::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionFromTwoVectors
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MathQuaternionFromTwoVectors final : public FRigUnit_MathQuaternionBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionFromTwoVectors) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionFromTwoVectors");
static_assert(sizeof(FRigUnit_MathQuaternionFromTwoVectors) == 0x000050, "Wrong size on FRigUnit_MathQuaternionFromTwoVectors");
static_assert(offsetof(FRigUnit_MathQuaternionFromTwoVectors, A) == 0x000020, "Member 'FRigUnit_MathQuaternionFromTwoVectors::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromTwoVectors, B) == 0x00002C, "Member 'FRigUnit_MathQuaternionFromTwoVectors::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromTwoVectors, Result) == 0x000040, "Member 'FRigUnit_MathQuaternionFromTwoVectors::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolNotEquals
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_MathBoolNotEquals final : public FRigUnit_MathBoolBase
{
public:
	bool                                          A;                                                 // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolNotEquals) == 0x000008, "Wrong alignment on FRigUnit_MathBoolNotEquals");
static_assert(sizeof(FRigUnit_MathBoolNotEquals) == 0x000028, "Wrong size on FRigUnit_MathBoolNotEquals");
static_assert(offsetof(FRigUnit_MathBoolNotEquals, A) == 0x000020, "Member 'FRigUnit_MathBoolNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolNotEquals, B) == 0x000021, "Member 'FRigUnit_MathBoolNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolNotEquals, Result) == 0x000022, "Member 'FRigUnit_MathBoolNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolEquals
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_MathBoolEquals final : public FRigUnit_MathBoolBase
{
public:
	bool                                          A;                                                 // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolEquals) == 0x000008, "Wrong alignment on FRigUnit_MathBoolEquals");
static_assert(sizeof(FRigUnit_MathBoolEquals) == 0x000028, "Wrong size on FRigUnit_MathBoolEquals");
static_assert(offsetof(FRigUnit_MathBoolEquals, A) == 0x000020, "Member 'FRigUnit_MathBoolEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolEquals, B) == 0x000021, "Member 'FRigUnit_MathBoolEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolEquals, Result) == 0x000022, "Member 'FRigUnit_MathBoolEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolOr
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathBoolOr final : public FRigUnit_MathBoolBinaryOp
{
};
static_assert(alignof(FRigUnit_MathBoolOr) == 0x000008, "Wrong alignment on FRigUnit_MathBoolOr");
static_assert(sizeof(FRigUnit_MathBoolOr) == 0x000028, "Wrong size on FRigUnit_MathBoolOr");

// ScriptStruct ControlRig.RigUnit_MathBoolNand
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathBoolNand final : public FRigUnit_MathBoolBinaryOp
{
};
static_assert(alignof(FRigUnit_MathBoolNand) == 0x000008, "Wrong alignment on FRigUnit_MathBoolNand");
static_assert(sizeof(FRigUnit_MathBoolNand) == 0x000028, "Wrong size on FRigUnit_MathBoolNand");

// ScriptStruct ControlRig.RigUnit_MathQuaternionRotateVector
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MathQuaternionRotateVector final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  Quaternion;                                        // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionRotateVector) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionRotateVector");
static_assert(sizeof(FRigUnit_MathQuaternionRotateVector) == 0x000050, "Wrong size on FRigUnit_MathQuaternionRotateVector");
static_assert(offsetof(FRigUnit_MathQuaternionRotateVector, Quaternion) == 0x000020, "Member 'FRigUnit_MathQuaternionRotateVector::Quaternion' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionRotateVector, Vector) == 0x000030, "Member 'FRigUnit_MathQuaternionRotateVector::Vector' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionRotateVector, Result) == 0x00003C, "Member 'FRigUnit_MathQuaternionRotateVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolUnaryOp
// 0x0008 (0x0028 - 0x0020)
struct FRigUnit_MathBoolUnaryOp : public FRigUnit_MathBoolBase
{
public:
	bool                                          Value;                                             // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathBoolUnaryOp) == 0x000008, "Wrong alignment on FRigUnit_MathBoolUnaryOp");
static_assert(sizeof(FRigUnit_MathBoolUnaryOp) == 0x000028, "Wrong size on FRigUnit_MathBoolUnaryOp");
static_assert(offsetof(FRigUnit_MathBoolUnaryOp, Value) == 0x000020, "Member 'FRigUnit_MathBoolUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathBoolUnaryOp, Result) == 0x000021, "Member 'FRigUnit_MathBoolUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolNot
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathBoolNot final : public FRigUnit_MathBoolUnaryOp
{
};
static_assert(alignof(FRigUnit_MathBoolNot) == 0x000008, "Wrong alignment on FRigUnit_MathBoolNot");
static_assert(sizeof(FRigUnit_MathBoolNot) == 0x000028, "Wrong size on FRigUnit_MathBoolNot");

// ScriptStruct ControlRig.RigUnit_MathQuaternionUnaryOp
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathQuaternionUnaryOp : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  Value;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionUnaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionUnaryOp");
static_assert(sizeof(FRigUnit_MathQuaternionUnaryOp) == 0x000040, "Wrong size on FRigUnit_MathQuaternionUnaryOp");
static_assert(offsetof(FRigUnit_MathQuaternionUnaryOp, Value) == 0x000020, "Member 'FRigUnit_MathQuaternionUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionUnaryOp, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_NoiseVector
// 0x0048 (0x0068 - 0x0020)
struct FRigUnit_NoiseVector final : public FRigUnit_MathBase
{
public:
	struct FVector                                Position;                                          // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Speed;                                             // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Frequency;                                         // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x004C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Time;                                              // 0x0058(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_NoiseVector) == 0x000008, "Wrong alignment on FRigUnit_NoiseVector");
static_assert(sizeof(FRigUnit_NoiseVector) == 0x000068, "Wrong size on FRigUnit_NoiseVector");
static_assert(offsetof(FRigUnit_NoiseVector, Position) == 0x000020, "Member 'FRigUnit_NoiseVector::Position' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Speed) == 0x00002C, "Member 'FRigUnit_NoiseVector::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Frequency) == 0x000038, "Member 'FRigUnit_NoiseVector::Frequency' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Minimum) == 0x000044, "Member 'FRigUnit_NoiseVector::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Maximum) == 0x000048, "Member 'FRigUnit_NoiseVector::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Result) == 0x00004C, "Member 'FRigUnit_NoiseVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_NoiseVector, Time) == 0x000058, "Member 'FRigUnit_NoiseVector::Time' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathBoolConstFalse
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathBoolConstFalse final : public FRigUnit_MathBoolConstant
{
};
static_assert(alignof(FRigUnit_MathBoolConstFalse) == 0x000008, "Wrong alignment on FRigUnit_MathBoolConstFalse");
static_assert(sizeof(FRigUnit_MathBoolConstFalse) == 0x000028, "Wrong size on FRigUnit_MathBoolConstFalse");

// ScriptStruct ControlRig.RigUnit_MathQuaternionDot
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MathQuaternionDot final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  A;                                                 // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionDot) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionDot");
static_assert(sizeof(FRigUnit_MathQuaternionDot) == 0x000050, "Wrong size on FRigUnit_MathQuaternionDot");
static_assert(offsetof(FRigUnit_MathQuaternionDot, A) == 0x000020, "Member 'FRigUnit_MathQuaternionDot::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionDot, B) == 0x000030, "Member 'FRigUnit_MathQuaternionDot::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionDot, Result) == 0x000040, "Member 'FRigUnit_MathQuaternionDot::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatAtan
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatAtan final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAtan) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAtan");
static_assert(sizeof(FRigUnit_MathFloatAtan) == 0x000028, "Wrong size on FRigUnit_MathFloatAtan");

// ScriptStruct ControlRig.RigUnit_MathFloatAcos
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatAcos final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAcos) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAcos");
static_assert(sizeof(FRigUnit_MathFloatAcos) == 0x000028, "Wrong size on FRigUnit_MathFloatAcos");

// ScriptStruct ControlRig.RigUnit_MathFloatAsin
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatAsin final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAsin) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAsin");
static_assert(sizeof(FRigUnit_MathFloatAsin) == 0x000028, "Wrong size on FRigUnit_MathFloatAsin");

// ScriptStruct ControlRig.RigUnit_MathFloatSin
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatSin final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatSin) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSin");
static_assert(sizeof(FRigUnit_MathFloatSin) == 0x000028, "Wrong size on FRigUnit_MathFloatSin");

// ScriptStruct ControlRig.RigUnit_MathFloatRad
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatRad final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatRad) == 0x000008, "Wrong alignment on FRigUnit_MathFloatRad");
static_assert(sizeof(FRigUnit_MathFloatRad) == 0x000028, "Wrong size on FRigUnit_MathFloatRad");

// ScriptStruct ControlRig.RigUnit_MathFloatDeg
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatDeg final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatDeg) == 0x000008, "Wrong alignment on FRigUnit_MathFloatDeg");
static_assert(sizeof(FRigUnit_MathFloatDeg) == 0x000028, "Wrong size on FRigUnit_MathFloatDeg");

// ScriptStruct ControlRig.RigUnit_MathFloatSelectBool
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatSelectBool final : public FRigUnit_MathFloatBase
{
public:
	bool                                          Condition;                                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IfTrue;                                            // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IfFalse;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatSelectBool) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSelectBool");
static_assert(sizeof(FRigUnit_MathFloatSelectBool) == 0x000030, "Wrong size on FRigUnit_MathFloatSelectBool");
static_assert(offsetof(FRigUnit_MathFloatSelectBool, Condition) == 0x000020, "Member 'FRigUnit_MathFloatSelectBool::Condition' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatSelectBool, IfTrue) == 0x000024, "Member 'FRigUnit_MathFloatSelectBool::IfTrue' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatSelectBool, IfFalse) == 0x000028, "Member 'FRigUnit_MathFloatSelectBool::IfFalse' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatSelectBool, Result) == 0x00002C, "Member 'FRigUnit_MathFloatSelectBool::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatIsNearlyEqual
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatIsNearlyEqual final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatIsNearlyEqual) == 0x000008, "Wrong alignment on FRigUnit_MathFloatIsNearlyEqual");
static_assert(sizeof(FRigUnit_MathFloatIsNearlyEqual) == 0x000030, "Wrong size on FRigUnit_MathFloatIsNearlyEqual");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyEqual, A) == 0x000020, "Member 'FRigUnit_MathFloatIsNearlyEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyEqual, B) == 0x000024, "Member 'FRigUnit_MathFloatIsNearlyEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyEqual, Tolerance) == 0x000028, "Member 'FRigUnit_MathFloatIsNearlyEqual::Tolerance' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyEqual, Result) == 0x00002C, "Member 'FRigUnit_MathFloatIsNearlyEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionInverse
// 0x0000 (0x0040 - 0x0040)
struct FRigUnit_MathQuaternionInverse final : public FRigUnit_MathQuaternionUnaryOp
{
};
static_assert(alignof(FRigUnit_MathQuaternionInverse) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionInverse");
static_assert(sizeof(FRigUnit_MathQuaternionInverse) == 0x000040, "Wrong size on FRigUnit_MathQuaternionInverse");

// ScriptStruct ControlRig.RigUnit_MathFloatIsNearlyZero
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatIsNearlyZero final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatIsNearlyZero) == 0x000008, "Wrong alignment on FRigUnit_MathFloatIsNearlyZero");
static_assert(sizeof(FRigUnit_MathFloatIsNearlyZero) == 0x000030, "Wrong size on FRigUnit_MathFloatIsNearlyZero");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyZero, Value) == 0x000020, "Member 'FRigUnit_MathFloatIsNearlyZero::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyZero, Tolerance) == 0x000024, "Member 'FRigUnit_MathFloatIsNearlyZero::Tolerance' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatIsNearlyZero, Result) == 0x000028, "Member 'FRigUnit_MathFloatIsNearlyZero::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatLessEqual
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatLessEqual final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatLessEqual) == 0x000008, "Wrong alignment on FRigUnit_MathFloatLessEqual");
static_assert(sizeof(FRigUnit_MathFloatLessEqual) == 0x000030, "Wrong size on FRigUnit_MathFloatLessEqual");
static_assert(offsetof(FRigUnit_MathFloatLessEqual, A) == 0x000020, "Member 'FRigUnit_MathFloatLessEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLessEqual, B) == 0x000024, "Member 'FRigUnit_MathFloatLessEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLessEqual, Result) == 0x000028, "Member 'FRigUnit_MathFloatLessEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatGreaterEqual
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatGreaterEqual final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatGreaterEqual) == 0x000008, "Wrong alignment on FRigUnit_MathFloatGreaterEqual");
static_assert(sizeof(FRigUnit_MathFloatGreaterEqual) == 0x000030, "Wrong size on FRigUnit_MathFloatGreaterEqual");
static_assert(offsetof(FRigUnit_MathFloatGreaterEqual, A) == 0x000020, "Member 'FRigUnit_MathFloatGreaterEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatGreaterEqual, B) == 0x000024, "Member 'FRigUnit_MathFloatGreaterEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatGreaterEqual, Result) == 0x000028, "Member 'FRigUnit_MathFloatGreaterEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatLess
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatLess final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatLess) == 0x000008, "Wrong alignment on FRigUnit_MathFloatLess");
static_assert(sizeof(FRigUnit_MathFloatLess) == 0x000030, "Wrong size on FRigUnit_MathFloatLess");
static_assert(offsetof(FRigUnit_MathFloatLess, A) == 0x000020, "Member 'FRigUnit_MathFloatLess::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLess, B) == 0x000024, "Member 'FRigUnit_MathFloatLess::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLess, Result) == 0x000028, "Member 'FRigUnit_MathFloatLess::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SetBoneTransform
// 0x0048 (0x0080 - 0x0038)
struct FRigUnit_SetBoneTransform final : public FRigUnitMutable
{
public:
	class FName                                   Bone;                                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0040(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedBoneIndex;                                   // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetBoneTransform) == 0x000010, "Wrong alignment on FRigUnit_SetBoneTransform");
static_assert(sizeof(FRigUnit_SetBoneTransform) == 0x000080, "Wrong size on FRigUnit_SetBoneTransform");
static_assert(offsetof(FRigUnit_SetBoneTransform, Bone) == 0x000038, "Member 'FRigUnit_SetBoneTransform::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, Transform) == 0x000040, "Member 'FRigUnit_SetBoneTransform::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, Space) == 0x000070, "Member 'FRigUnit_SetBoneTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, bPropagateToChildren) == 0x000071, "Member 'FRigUnit_SetBoneTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneTransform, CachedBoneIndex) == 0x000074, "Member 'FRigUnit_SetBoneTransform::CachedBoneIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatGreater
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatGreater final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatGreater) == 0x000008, "Wrong alignment on FRigUnit_MathFloatGreater");
static_assert(sizeof(FRigUnit_MathFloatGreater) == 0x000030, "Wrong size on FRigUnit_MathFloatGreater");
static_assert(offsetof(FRigUnit_MathFloatGreater, A) == 0x000020, "Member 'FRigUnit_MathFloatGreater::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatGreater, B) == 0x000024, "Member 'FRigUnit_MathFloatGreater::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatGreater, Result) == 0x000028, "Member 'FRigUnit_MathFloatGreater::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatNotEquals
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatNotEquals final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatNotEquals) == 0x000008, "Wrong alignment on FRigUnit_MathFloatNotEquals");
static_assert(sizeof(FRigUnit_MathFloatNotEquals) == 0x000030, "Wrong size on FRigUnit_MathFloatNotEquals");
static_assert(offsetof(FRigUnit_MathFloatNotEquals, A) == 0x000020, "Member 'FRigUnit_MathFloatNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatNotEquals, B) == 0x000024, "Member 'FRigUnit_MathFloatNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatNotEquals, Result) == 0x000028, "Member 'FRigUnit_MathFloatNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatEquals
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatEquals final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathFloatEquals) == 0x000008, "Wrong alignment on FRigUnit_MathFloatEquals");
static_assert(sizeof(FRigUnit_MathFloatEquals) == 0x000030, "Wrong size on FRigUnit_MathFloatEquals");
static_assert(offsetof(FRigUnit_MathFloatEquals, A) == 0x000020, "Member 'FRigUnit_MathFloatEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatEquals, B) == 0x000024, "Member 'FRigUnit_MathFloatEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatEquals, Result) == 0x000028, "Member 'FRigUnit_MathFloatEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatLerp
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatLerp final : public FRigUnit_MathFloatBase
{
public:
	float                                         A;                                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatLerp) == 0x000008, "Wrong alignment on FRigUnit_MathFloatLerp");
static_assert(sizeof(FRigUnit_MathFloatLerp) == 0x000030, "Wrong size on FRigUnit_MathFloatLerp");
static_assert(offsetof(FRigUnit_MathFloatLerp, A) == 0x000020, "Member 'FRigUnit_MathFloatLerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLerp, B) == 0x000024, "Member 'FRigUnit_MathFloatLerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLerp, T) == 0x000028, "Member 'FRigUnit_MathFloatLerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatLerp, Result) == 0x00002C, "Member 'FRigUnit_MathFloatLerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatClamp
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathFloatClamp final : public FRigUnit_MathFloatBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathFloatClamp) == 0x000008, "Wrong alignment on FRigUnit_MathFloatClamp");
static_assert(sizeof(FRigUnit_MathFloatClamp) == 0x000030, "Wrong size on FRigUnit_MathFloatClamp");
static_assert(offsetof(FRigUnit_MathFloatClamp, Value) == 0x000020, "Member 'FRigUnit_MathFloatClamp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatClamp, Minimum) == 0x000024, "Member 'FRigUnit_MathFloatClamp::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatClamp, Maximum) == 0x000028, "Member 'FRigUnit_MathFloatClamp::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathFloatClamp, Result) == 0x00002C, "Member 'FRigUnit_MathFloatClamp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatRound
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatRound final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatRound) == 0x000008, "Wrong alignment on FRigUnit_MathFloatRound");
static_assert(sizeof(FRigUnit_MathFloatRound) == 0x000028, "Wrong size on FRigUnit_MathFloatRound");

// ScriptStruct ControlRig.RigUnit_MathFloatCeil
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatCeil final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatCeil) == 0x000008, "Wrong alignment on FRigUnit_MathFloatCeil");
static_assert(sizeof(FRigUnit_MathFloatCeil) == 0x000028, "Wrong size on FRigUnit_MathFloatCeil");

// ScriptStruct ControlRig.RigUnit_MathFloatFloor
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatFloor final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatFloor) == 0x000008, "Wrong alignment on FRigUnit_MathFloatFloor");
static_assert(sizeof(FRigUnit_MathFloatFloor) == 0x000028, "Wrong size on FRigUnit_MathFloatFloor");

// ScriptStruct ControlRig.RigUnit_MathFloatAbs
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatAbs final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAbs) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAbs");
static_assert(sizeof(FRigUnit_MathFloatAbs) == 0x000028, "Wrong size on FRigUnit_MathFloatAbs");

// ScriptStruct ControlRig.RigUnit_MathFloatNegate
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatNegate final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatNegate) == 0x000008, "Wrong alignment on FRigUnit_MathFloatNegate");
static_assert(sizeof(FRigUnit_MathFloatNegate) == 0x000028, "Wrong size on FRigUnit_MathFloatNegate");

// ScriptStruct ControlRig.RigUnit_MathFloatSqrt
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatSqrt final : public FRigUnit_MathFloatUnaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatSqrt) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSqrt");
static_assert(sizeof(FRigUnit_MathFloatSqrt) == 0x000028, "Wrong size on FRigUnit_MathFloatSqrt");

// ScriptStruct ControlRig.RigUnit_MathFloatPow
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_MathFloatPow final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatPow) == 0x000008, "Wrong alignment on FRigUnit_MathFloatPow");
static_assert(sizeof(FRigUnit_MathFloatPow) == 0x000030, "Wrong size on FRigUnit_MathFloatPow");

// ScriptStruct ControlRig.RigUnit_MathFloatMax
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_MathFloatMax final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatMax) == 0x000008, "Wrong alignment on FRigUnit_MathFloatMax");
static_assert(sizeof(FRigUnit_MathFloatMax) == 0x000030, "Wrong size on FRigUnit_MathFloatMax");

// ScriptStruct ControlRig.RigUnit_MathFloatMod
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_MathFloatMod final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatMod) == 0x000008, "Wrong alignment on FRigUnit_MathFloatMod");
static_assert(sizeof(FRigUnit_MathFloatMod) == 0x000030, "Wrong size on FRigUnit_MathFloatMod");

// ScriptStruct ControlRig.RigUnit_MathFloatDiv
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_MathFloatDiv final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatDiv) == 0x000008, "Wrong alignment on FRigUnit_MathFloatDiv");
static_assert(sizeof(FRigUnit_MathFloatDiv) == 0x000030, "Wrong size on FRigUnit_MathFloatDiv");

// ScriptStruct ControlRig.RigUnit_MathFloatMul
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_MathFloatMul final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatMul) == 0x000008, "Wrong alignment on FRigUnit_MathFloatMul");
static_assert(sizeof(FRigUnit_MathFloatMul) == 0x000030, "Wrong size on FRigUnit_MathFloatMul");

// ScriptStruct ControlRig.RigUnit_MathFloatSub
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_MathFloatSub final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatSub) == 0x000008, "Wrong alignment on FRigUnit_MathFloatSub");
static_assert(sizeof(FRigUnit_MathFloatSub) == 0x000030, "Wrong size on FRigUnit_MathFloatSub");

// ScriptStruct ControlRig.RigUnit_RandomFloat
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_RandomFloat final : public FRigUnit_MathBase
{
public:
	int32                                         Seed;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastResult;                                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastSeed;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLeft;                                          // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_RandomFloat) == 0x000008, "Wrong alignment on FRigUnit_RandomFloat");
static_assert(sizeof(FRigUnit_RandomFloat) == 0x000040, "Wrong size on FRigUnit_RandomFloat");
static_assert(offsetof(FRigUnit_RandomFloat, Seed) == 0x000020, "Member 'FRigUnit_RandomFloat::Seed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, Minimum) == 0x000024, "Member 'FRigUnit_RandomFloat::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, Maximum) == 0x000028, "Member 'FRigUnit_RandomFloat::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, Duration) == 0x00002C, "Member 'FRigUnit_RandomFloat::Duration' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, Result) == 0x000030, "Member 'FRigUnit_RandomFloat::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, LastResult) == 0x000034, "Member 'FRigUnit_RandomFloat::LastResult' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, LastSeed) == 0x000038, "Member 'FRigUnit_RandomFloat::LastSeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_RandomFloat, TimeLeft) == 0x00003C, "Member 'FRigUnit_RandomFloat::TimeLeft' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathFloatAdd
// 0x0000 (0x0030 - 0x0030)
struct FRigUnit_MathFloatAdd final : public FRigUnit_MathFloatBinaryOp
{
};
static_assert(alignof(FRigUnit_MathFloatAdd) == 0x000008, "Wrong alignment on FRigUnit_MathFloatAdd");
static_assert(sizeof(FRigUnit_MathFloatAdd) == 0x000030, "Wrong size on FRigUnit_MathFloatAdd");

// ScriptStruct ControlRig.RigUnit_MathFloatConstPi
// 0x0000 (0x0028 - 0x0028)
struct FRigUnit_MathFloatConstPi final : public FRigUnit_MathFloatConstant
{
};
static_assert(alignof(FRigUnit_MathFloatConstPi) == 0x000008, "Wrong alignment on FRigUnit_MathFloatConstPi");
static_assert(sizeof(FRigUnit_MathFloatConstPi) == 0x000028, "Wrong size on FRigUnit_MathFloatConstPi");

// ScriptStruct ControlRig.RigUnit_MathQuaternionSwingTwist
// 0x0040 (0x0060 - 0x0020)
struct FRigUnit_MathQuaternionSwingTwist final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  Input;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TwistAxis;                                         // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Swing;                                             // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Twist;                                             // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionSwingTwist) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionSwingTwist");
static_assert(sizeof(FRigUnit_MathQuaternionSwingTwist) == 0x000060, "Wrong size on FRigUnit_MathQuaternionSwingTwist");
static_assert(offsetof(FRigUnit_MathQuaternionSwingTwist, Input) == 0x000020, "Member 'FRigUnit_MathQuaternionSwingTwist::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSwingTwist, TwistAxis) == 0x000030, "Member 'FRigUnit_MathQuaternionSwingTwist::TwistAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSwingTwist, Swing) == 0x000040, "Member 'FRigUnit_MathQuaternionSwingTwist::Swing' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSwingTwist, Twist) == 0x000050, "Member 'FRigUnit_MathQuaternionSwingTwist::Twist' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionGetAxis
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathQuaternionGetAxis final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  Quaternion;                                        // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAxis                                         Axis;                                              // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionGetAxis) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionGetAxis");
static_assert(sizeof(FRigUnit_MathQuaternionGetAxis) == 0x000040, "Wrong size on FRigUnit_MathQuaternionGetAxis");
static_assert(offsetof(FRigUnit_MathQuaternionGetAxis, Quaternion) == 0x000020, "Member 'FRigUnit_MathQuaternionGetAxis::Quaternion' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionGetAxis, Axis) == 0x000030, "Member 'FRigUnit_MathQuaternionGetAxis::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionGetAxis, Result) == 0x000034, "Member 'FRigUnit_MathQuaternionGetAxis::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionUnit
// 0x0000 (0x0040 - 0x0040)
struct FRigUnit_MathQuaternionUnit final : public FRigUnit_MathQuaternionUnaryOp
{
};
static_assert(alignof(FRigUnit_MathQuaternionUnit) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionUnit");
static_assert(sizeof(FRigUnit_MathQuaternionUnit) == 0x000040, "Wrong size on FRigUnit_MathQuaternionUnit");

// ScriptStruct ControlRig.RigUnit_MathQuaternionSelectBool
// 0x0040 (0x0060 - 0x0020)
struct FRigUnit_MathQuaternionSelectBool final : public FRigUnit_MathQuaternionBase
{
public:
	bool                                          Condition;                                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  IfTrue;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  IfFalse;                                           // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionSelectBool) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionSelectBool");
static_assert(sizeof(FRigUnit_MathQuaternionSelectBool) == 0x000060, "Wrong size on FRigUnit_MathQuaternionSelectBool");
static_assert(offsetof(FRigUnit_MathQuaternionSelectBool, Condition) == 0x000020, "Member 'FRigUnit_MathQuaternionSelectBool::Condition' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSelectBool, IfTrue) == 0x000030, "Member 'FRigUnit_MathQuaternionSelectBool::IfTrue' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSelectBool, IfFalse) == 0x000040, "Member 'FRigUnit_MathQuaternionSelectBool::IfFalse' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSelectBool, Result) == 0x000050, "Member 'FRigUnit_MathQuaternionSelectBool::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionNotEquals
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MathQuaternionNotEquals final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  A;                                                 // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionNotEquals) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionNotEquals");
static_assert(sizeof(FRigUnit_MathQuaternionNotEquals) == 0x000050, "Wrong size on FRigUnit_MathQuaternionNotEquals");
static_assert(offsetof(FRigUnit_MathQuaternionNotEquals, A) == 0x000020, "Member 'FRigUnit_MathQuaternionNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionNotEquals, B) == 0x000030, "Member 'FRigUnit_MathQuaternionNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionNotEquals, Result) == 0x000040, "Member 'FRigUnit_MathQuaternionNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionEquals
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MathQuaternionEquals final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  A;                                                 // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionEquals) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionEquals");
static_assert(sizeof(FRigUnit_MathQuaternionEquals) == 0x000050, "Wrong size on FRigUnit_MathQuaternionEquals");
static_assert(offsetof(FRigUnit_MathQuaternionEquals, A) == 0x000020, "Member 'FRigUnit_MathQuaternionEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionEquals, B) == 0x000030, "Member 'FRigUnit_MathQuaternionEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionEquals, Result) == 0x000040, "Member 'FRigUnit_MathQuaternionEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionSlerp
// 0x0040 (0x0060 - 0x0020)
struct FRigUnit_MathQuaternionSlerp final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  A;                                                 // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  B;                                                 // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionSlerp) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionSlerp");
static_assert(sizeof(FRigUnit_MathQuaternionSlerp) == 0x000060, "Wrong size on FRigUnit_MathQuaternionSlerp");
static_assert(offsetof(FRigUnit_MathQuaternionSlerp, A) == 0x000020, "Member 'FRigUnit_MathQuaternionSlerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSlerp, B) == 0x000030, "Member 'FRigUnit_MathQuaternionSlerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSlerp, T) == 0x000040, "Member 'FRigUnit_MathQuaternionSlerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionSlerp, Result) == 0x000050, "Member 'FRigUnit_MathQuaternionSlerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryQuaternionOp
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_BinaryQuaternionOp : public FRigUnit
{
public:
	struct FQuat                                  Argument0;                                         // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Argument1;                                         // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BinaryQuaternionOp) == 0x000010, "Wrong alignment on FRigUnit_BinaryQuaternionOp");
static_assert(sizeof(FRigUnit_BinaryQuaternionOp) == 0x000050, "Wrong size on FRigUnit_BinaryQuaternionOp");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Argument0) == 0x000020, "Member 'FRigUnit_BinaryQuaternionOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Argument1) == 0x000030, "Member 'FRigUnit_BinaryQuaternionOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryQuaternionOp, Result) == 0x000040, "Member 'FRigUnit_BinaryQuaternionOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionMul
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MathQuaternionMul final : public FRigUnit_MathQuaternionBinaryOp
{
};
static_assert(alignof(FRigUnit_MathQuaternionMul) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionMul");
static_assert(sizeof(FRigUnit_MathQuaternionMul) == 0x000050, "Wrong size on FRigUnit_MathQuaternionMul");

// ScriptStruct ControlRig.RigUnit_MathQuaternionToRotator
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathQuaternionToRotator final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  Value;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Result;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathQuaternionToRotator) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionToRotator");
static_assert(sizeof(FRigUnit_MathQuaternionToRotator) == 0x000040, "Wrong size on FRigUnit_MathQuaternionToRotator");
static_assert(offsetof(FRigUnit_MathQuaternionToRotator, Value) == 0x000020, "Member 'FRigUnit_MathQuaternionToRotator::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToRotator, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionToRotator::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_BinaryTransformOp
// 0x0090 (0x00B0 - 0x0020)
struct FRigUnit_BinaryTransformOp : public FRigUnit
{
public:
	struct FTransform                             Argument0;                                         // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Argument1;                                         // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0080(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BinaryTransformOp) == 0x000010, "Wrong alignment on FRigUnit_BinaryTransformOp");
static_assert(sizeof(FRigUnit_BinaryTransformOp) == 0x0000B0, "Wrong size on FRigUnit_BinaryTransformOp");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Argument0) == 0x000020, "Member 'FRigUnit_BinaryTransformOp::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Argument1) == 0x000050, "Member 'FRigUnit_BinaryTransformOp::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_BinaryTransformOp, Result) == 0x000080, "Member 'FRigUnit_BinaryTransformOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_GetRelativeTransform
// 0x0000 (0x00B0 - 0x00B0)
struct FRigUnit_GetRelativeTransform final : public FRigUnit_BinaryTransformOp
{
};
static_assert(alignof(FRigUnit_GetRelativeTransform) == 0x000010, "Wrong alignment on FRigUnit_GetRelativeTransform");
static_assert(sizeof(FRigUnit_GetRelativeTransform) == 0x0000B0, "Wrong size on FRigUnit_GetRelativeTransform");

// ScriptStruct ControlRig.RigUnit_MathQuaternionToEuler
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathQuaternionToEuler final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  Value;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EControlRigRotationOrder                      RotationOrder;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Result;                                            // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionToEuler) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionToEuler");
static_assert(sizeof(FRigUnit_MathQuaternionToEuler) == 0x000040, "Wrong size on FRigUnit_MathQuaternionToEuler");
static_assert(offsetof(FRigUnit_MathQuaternionToEuler, Value) == 0x000020, "Member 'FRigUnit_MathQuaternionToEuler::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToEuler, RotationOrder) == 0x000030, "Member 'FRigUnit_MathQuaternionToEuler::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToEuler, Result) == 0x000034, "Member 'FRigUnit_MathQuaternionToEuler::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionToAxisAndAngle
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathQuaternionToAxisAndAngle final : public FRigUnit_MathQuaternionBase
{
public:
	struct FQuat                                  Value;                                             // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionToAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionToAxisAndAngle");
static_assert(sizeof(FRigUnit_MathQuaternionToAxisAndAngle) == 0x000040, "Wrong size on FRigUnit_MathQuaternionToAxisAndAngle");
static_assert(offsetof(FRigUnit_MathQuaternionToAxisAndAngle, Value) == 0x000020, "Member 'FRigUnit_MathQuaternionToAxisAndAngle::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToAxisAndAngle, Axis) == 0x000030, "Member 'FRigUnit_MathQuaternionToAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionToAxisAndAngle, Angle) == 0x00003C, "Member 'FRigUnit_MathQuaternionToAxisAndAngle::Angle' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionFromRotator
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathQuaternionFromRotator final : public FRigUnit_MathQuaternionBase
{
public:
	struct FRotator                               Rotator;                                           // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionFromRotator) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionFromRotator");
static_assert(sizeof(FRigUnit_MathQuaternionFromRotator) == 0x000040, "Wrong size on FRigUnit_MathQuaternionFromRotator");
static_assert(offsetof(FRigUnit_MathQuaternionFromRotator, Rotator) == 0x000020, "Member 'FRigUnit_MathQuaternionFromRotator::Rotator' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromRotator, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionFromRotator::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionFromEuler
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathQuaternionFromEuler final : public FRigUnit_MathQuaternionBase
{
public:
	struct FVector                                Euler;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigRotationOrder                      RotationOrder;                                     // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionFromEuler) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionFromEuler");
static_assert(sizeof(FRigUnit_MathQuaternionFromEuler) == 0x000040, "Wrong size on FRigUnit_MathQuaternionFromEuler");
static_assert(offsetof(FRigUnit_MathQuaternionFromEuler, Euler) == 0x000020, "Member 'FRigUnit_MathQuaternionFromEuler::Euler' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromEuler, RotationOrder) == 0x00002C, "Member 'FRigUnit_MathQuaternionFromEuler::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromEuler, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionFromEuler::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathQuaternionFromAxisAndAngle
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathQuaternionFromAxisAndAngle final : public FRigUnit_MathQuaternionBase
{
public:
	struct FVector                                Axis;                                              // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathQuaternionFromAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_MathQuaternionFromAxisAndAngle");
static_assert(sizeof(FRigUnit_MathQuaternionFromAxisAndAngle) == 0x000040, "Wrong size on FRigUnit_MathQuaternionFromAxisAndAngle");
static_assert(offsetof(FRigUnit_MathQuaternionFromAxisAndAngle, Axis) == 0x000020, "Member 'FRigUnit_MathQuaternionFromAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromAxisAndAngle, Angle) == 0x00002C, "Member 'FRigUnit_MathQuaternionFromAxisAndAngle::Angle' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathQuaternionFromAxisAndAngle, Result) == 0x000030, "Member 'FRigUnit_MathQuaternionFromAxisAndAngle::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorScale
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorScale final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Factor;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorScale) == 0x000008, "Wrong alignment on FRigUnit_MathVectorScale");
static_assert(sizeof(FRigUnit_MathVectorScale) == 0x000040, "Wrong size on FRigUnit_MathVectorScale");
static_assert(offsetof(FRigUnit_MathVectorScale, Value) == 0x000020, "Member 'FRigUnit_MathVectorScale::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorScale, Factor) == 0x00002C, "Member 'FRigUnit_MathVectorScale::Factor' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorScale, Result) == 0x000030, "Member 'FRigUnit_MathVectorScale::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformFromSRT
// 0x0090 (0x00B0 - 0x0020)
struct FRigUnit_MathTransformFromSRT final : public FRigUnit_MathTransformBase
{
public:
	struct FVector                                Location;                                          // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigRotationOrder                      RotationOrder;                                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEulerTransform                        EulerTransform;                                    // 0x0080(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0xC];                                       // 0x00A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathTransformFromSRT) == 0x000010, "Wrong alignment on FRigUnit_MathTransformFromSRT");
static_assert(sizeof(FRigUnit_MathTransformFromSRT) == 0x0000B0, "Wrong size on FRigUnit_MathTransformFromSRT");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, Location) == 0x000020, "Member 'FRigUnit_MathTransformFromSRT::Location' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, Rotation) == 0x00002C, "Member 'FRigUnit_MathTransformFromSRT::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, RotationOrder) == 0x000038, "Member 'FRigUnit_MathTransformFromSRT::RotationOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, Scale) == 0x00003C, "Member 'FRigUnit_MathTransformFromSRT::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, Transform) == 0x000050, "Member 'FRigUnit_MathTransformFromSRT::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromSRT, EulerTransform) == 0x000080, "Member 'FRigUnit_MathTransformFromSRT::EulerTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformTransformVector
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_MathTransformTransformVector final : public FRigUnit_MathTransformBase
{
public:
	struct FTransform                             Transform;                                         // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x005C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathTransformTransformVector) == 0x000010, "Wrong alignment on FRigUnit_MathTransformTransformVector");
static_assert(sizeof(FRigUnit_MathTransformTransformVector) == 0x000070, "Wrong size on FRigUnit_MathTransformTransformVector");
static_assert(offsetof(FRigUnit_MathTransformTransformVector, Transform) == 0x000020, "Member 'FRigUnit_MathTransformTransformVector::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformTransformVector, Location) == 0x000050, "Member 'FRigUnit_MathTransformTransformVector::Location' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformTransformVector, Result) == 0x00005C, "Member 'FRigUnit_MathTransformTransformVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformRotateVector
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_MathTransformRotateVector final : public FRigUnit_MathTransformBase
{
public:
	struct FTransform                             Transform;                                         // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x005C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathTransformRotateVector) == 0x000010, "Wrong alignment on FRigUnit_MathTransformRotateVector");
static_assert(sizeof(FRigUnit_MathTransformRotateVector) == 0x000070, "Wrong size on FRigUnit_MathTransformRotateVector");
static_assert(offsetof(FRigUnit_MathTransformRotateVector, Transform) == 0x000020, "Member 'FRigUnit_MathTransformRotateVector::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformRotateVector, Direction) == 0x000050, "Member 'FRigUnit_MathTransformRotateVector::Direction' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformRotateVector, Result) == 0x00005C, "Member 'FRigUnit_MathTransformRotateVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformSelectBool
// 0x00A0 (0x00C0 - 0x0020)
struct FRigUnit_MathTransformSelectBool final : public FRigUnit_MathTransformBase
{
public:
	bool                                          Condition;                                         // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IfTrue;                                            // 0x0030(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             IfFalse;                                           // 0x0060(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformSelectBool) == 0x000010, "Wrong alignment on FRigUnit_MathTransformSelectBool");
static_assert(sizeof(FRigUnit_MathTransformSelectBool) == 0x0000C0, "Wrong size on FRigUnit_MathTransformSelectBool");
static_assert(offsetof(FRigUnit_MathTransformSelectBool, Condition) == 0x000020, "Member 'FRigUnit_MathTransformSelectBool::Condition' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformSelectBool, IfTrue) == 0x000030, "Member 'FRigUnit_MathTransformSelectBool::IfTrue' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformSelectBool, IfFalse) == 0x000060, "Member 'FRigUnit_MathTransformSelectBool::IfFalse' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformSelectBool, Result) == 0x000090, "Member 'FRigUnit_MathTransformSelectBool::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformUnaryOp
// 0x0060 (0x0080 - 0x0020)
struct FRigUnit_MathTransformUnaryOp : public FRigUnit_MathTransformBase
{
public:
	struct FTransform                             Value;                                             // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Result;                                            // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformUnaryOp) == 0x000010, "Wrong alignment on FRigUnit_MathTransformUnaryOp");
static_assert(sizeof(FRigUnit_MathTransformUnaryOp) == 0x000080, "Wrong size on FRigUnit_MathTransformUnaryOp");
static_assert(offsetof(FRigUnit_MathTransformUnaryOp, Value) == 0x000020, "Member 'FRigUnit_MathTransformUnaryOp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformUnaryOp, Result) == 0x000050, "Member 'FRigUnit_MathTransformUnaryOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorAbs
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorAbs final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorAbs) == 0x000008, "Wrong alignment on FRigUnit_MathVectorAbs");
static_assert(sizeof(FRigUnit_MathVectorAbs) == 0x000038, "Wrong size on FRigUnit_MathVectorAbs");

// ScriptStruct ControlRig.RigUnit_MathTransformInverse
// 0x0000 (0x0080 - 0x0080)
struct FRigUnit_MathTransformInverse final : public FRigUnit_MathTransformUnaryOp
{
};
static_assert(alignof(FRigUnit_MathTransformInverse) == 0x000010, "Wrong alignment on FRigUnit_MathTransformInverse");
static_assert(sizeof(FRigUnit_MathTransformInverse) == 0x000080, "Wrong size on FRigUnit_MathTransformInverse");

// ScriptStruct ControlRig.RigUnit_MathTransformMakeRelative
// 0x0090 (0x00B0 - 0x0020)
struct FRigUnit_MathTransformMakeRelative final : public FRigUnit_MathTransformBase
{
public:
	struct FTransform                             Global;                                            // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Parent;                                            // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Local;                                             // 0x0080(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformMakeRelative) == 0x000010, "Wrong alignment on FRigUnit_MathTransformMakeRelative");
static_assert(sizeof(FRigUnit_MathTransformMakeRelative) == 0x0000B0, "Wrong size on FRigUnit_MathTransformMakeRelative");
static_assert(offsetof(FRigUnit_MathTransformMakeRelative, Global) == 0x000020, "Member 'FRigUnit_MathTransformMakeRelative::Global' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformMakeRelative, Parent) == 0x000050, "Member 'FRigUnit_MathTransformMakeRelative::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformMakeRelative, Local) == 0x000080, "Member 'FRigUnit_MathTransformMakeRelative::Local' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformToEulerTransform
// 0x0060 (0x0080 - 0x0020)
struct FRigUnit_MathTransformToEulerTransform final : public FRigUnit_MathTransformBase
{
public:
	struct FTransform                             Value;                                             // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEulerTransform                        Result;                                            // 0x0050(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathTransformToEulerTransform) == 0x000010, "Wrong alignment on FRigUnit_MathTransformToEulerTransform");
static_assert(sizeof(FRigUnit_MathTransformToEulerTransform) == 0x000080, "Wrong size on FRigUnit_MathTransformToEulerTransform");
static_assert(offsetof(FRigUnit_MathTransformToEulerTransform, Value) == 0x000020, "Member 'FRigUnit_MathTransformToEulerTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformToEulerTransform, Result) == 0x000050, "Member 'FRigUnit_MathTransformToEulerTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathTransformFromEulerTransform
// 0x0060 (0x0080 - 0x0020)
struct FRigUnit_MathTransformFromEulerTransform final : public FRigUnit_MathTransformBase
{
public:
	struct FEulerTransform                        EulerTransform;                                    // 0x0020(0x0024)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathTransformFromEulerTransform) == 0x000010, "Wrong alignment on FRigUnit_MathTransformFromEulerTransform");
static_assert(sizeof(FRigUnit_MathTransformFromEulerTransform) == 0x000080, "Wrong size on FRigUnit_MathTransformFromEulerTransform");
static_assert(offsetof(FRigUnit_MathTransformFromEulerTransform, EulerTransform) == 0x000020, "Member 'FRigUnit_MathTransformFromEulerTransform::EulerTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathTransformFromEulerTransform, Result) == 0x000050, "Member 'FRigUnit_MathTransformFromEulerTransform::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMakeBezierFourPoint
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MathVectorMakeBezierFourPoint final : public FRigUnit_MathVectorBase
{
public:
	struct FCRFourPointBezier                     Bezier;                                            // 0x0020(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorMakeBezierFourPoint) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMakeBezierFourPoint");
static_assert(sizeof(FRigUnit_MathVectorMakeBezierFourPoint) == 0x000050, "Wrong size on FRigUnit_MathVectorMakeBezierFourPoint");
static_assert(offsetof(FRigUnit_MathVectorMakeBezierFourPoint, Bezier) == 0x000020, "Member 'FRigUnit_MathVectorMakeBezierFourPoint::Bezier' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorBezierFourPoint
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_MathVectorBezierFourPoint final : public FRigUnit_MathVectorBase
{
public:
	struct FCRFourPointBezier                     Bezier;                                            // 0x0020(0x0030)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0054(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tangent;                                           // 0x0060(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorBezierFourPoint) == 0x000008, "Wrong alignment on FRigUnit_MathVectorBezierFourPoint");
static_assert(sizeof(FRigUnit_MathVectorBezierFourPoint) == 0x000070, "Wrong size on FRigUnit_MathVectorBezierFourPoint");
static_assert(offsetof(FRigUnit_MathVectorBezierFourPoint, Bezier) == 0x000020, "Member 'FRigUnit_MathVectorBezierFourPoint::Bezier' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBezierFourPoint, T) == 0x000050, "Member 'FRigUnit_MathVectorBezierFourPoint::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBezierFourPoint, Result) == 0x000054, "Member 'FRigUnit_MathVectorBezierFourPoint::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorBezierFourPoint, Tangent) == 0x000060, "Member 'FRigUnit_MathVectorBezierFourPoint::Tangent' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorOrthogonal
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorOrthogonal final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorOrthogonal) == 0x000008, "Wrong alignment on FRigUnit_MathVectorOrthogonal");
static_assert(sizeof(FRigUnit_MathVectorOrthogonal) == 0x000040, "Wrong size on FRigUnit_MathVectorOrthogonal");
static_assert(offsetof(FRigUnit_MathVectorOrthogonal, A) == 0x000020, "Member 'FRigUnit_MathVectorOrthogonal::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorOrthogonal, B) == 0x00002C, "Member 'FRigUnit_MathVectorOrthogonal::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorOrthogonal, Result) == 0x000038, "Member 'FRigUnit_MathVectorOrthogonal::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorParallel
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorParallel final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorParallel) == 0x000008, "Wrong alignment on FRigUnit_MathVectorParallel");
static_assert(sizeof(FRigUnit_MathVectorParallel) == 0x000040, "Wrong size on FRigUnit_MathVectorParallel");
static_assert(offsetof(FRigUnit_MathVectorParallel, A) == 0x000020, "Member 'FRigUnit_MathVectorParallel::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorParallel, B) == 0x00002C, "Member 'FRigUnit_MathVectorParallel::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorParallel, Result) == 0x000038, "Member 'FRigUnit_MathVectorParallel::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorAngle
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorAngle final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorAngle) == 0x000008, "Wrong alignment on FRigUnit_MathVectorAngle");
static_assert(sizeof(FRigUnit_MathVectorAngle) == 0x000040, "Wrong size on FRigUnit_MathVectorAngle");
static_assert(offsetof(FRigUnit_MathVectorAngle, A) == 0x000020, "Member 'FRigUnit_MathVectorAngle::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorAngle, B) == 0x00002C, "Member 'FRigUnit_MathVectorAngle::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorAngle, Result) == 0x000038, "Member 'FRigUnit_MathVectorAngle::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorUnit
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorUnit final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorUnit) == 0x000008, "Wrong alignment on FRigUnit_MathVectorUnit");
static_assert(sizeof(FRigUnit_MathVectorUnit) == 0x000038, "Wrong size on FRigUnit_MathVectorUnit");

// ScriptStruct ControlRig.RigUnit_MathVectorDot
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorDot final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorDot) == 0x000008, "Wrong alignment on FRigUnit_MathVectorDot");
static_assert(sizeof(FRigUnit_MathVectorDot) == 0x000040, "Wrong size on FRigUnit_MathVectorDot");
static_assert(offsetof(FRigUnit_MathVectorDot, A) == 0x000020, "Member 'FRigUnit_MathVectorDot::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorDot, B) == 0x00002C, "Member 'FRigUnit_MathVectorDot::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorDot, Result) == 0x000038, "Member 'FRigUnit_MathVectorDot::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorDistance
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorDistance final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorDistance) == 0x000008, "Wrong alignment on FRigUnit_MathVectorDistance");
static_assert(sizeof(FRigUnit_MathVectorDistance) == 0x000040, "Wrong size on FRigUnit_MathVectorDistance");
static_assert(offsetof(FRigUnit_MathVectorDistance, A) == 0x000020, "Member 'FRigUnit_MathVectorDistance::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorDistance, B) == 0x00002C, "Member 'FRigUnit_MathVectorDistance::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorDistance, Result) == 0x000038, "Member 'FRigUnit_MathVectorDistance::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorLength
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathVectorLength final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorLength) == 0x000008, "Wrong alignment on FRigUnit_MathVectorLength");
static_assert(sizeof(FRigUnit_MathVectorLength) == 0x000030, "Wrong size on FRigUnit_MathVectorLength");
static_assert(offsetof(FRigUnit_MathVectorLength, Value) == 0x000020, "Member 'FRigUnit_MathVectorLength::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLength, Result) == 0x00002C, "Member 'FRigUnit_MathVectorLength::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMod
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_MathVectorMod final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorMod) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMod");
static_assert(sizeof(FRigUnit_MathVectorMod) == 0x000048, "Wrong size on FRigUnit_MathVectorMod");

// ScriptStruct ControlRig.RigUnit_MathVectorLengthSquared
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_MathVectorLengthSquared final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorLengthSquared) == 0x000008, "Wrong alignment on FRigUnit_MathVectorLengthSquared");
static_assert(sizeof(FRigUnit_MathVectorLengthSquared) == 0x000030, "Wrong size on FRigUnit_MathVectorLengthSquared");
static_assert(offsetof(FRigUnit_MathVectorLengthSquared, Value) == 0x000020, "Member 'FRigUnit_MathVectorLengthSquared::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLengthSquared, Result) == 0x00002C, "Member 'FRigUnit_MathVectorLengthSquared::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorMax
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_MathVectorMax final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorMax) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMax");
static_assert(sizeof(FRigUnit_MathVectorMax) == 0x000048, "Wrong size on FRigUnit_MathVectorMax");

// ScriptStruct ControlRig.RigUnit_MathVectorIsNearlyEqual
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorIsNearlyEqual final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorIsNearlyEqual) == 0x000008, "Wrong alignment on FRigUnit_MathVectorIsNearlyEqual");
static_assert(sizeof(FRigUnit_MathVectorIsNearlyEqual) == 0x000040, "Wrong size on FRigUnit_MathVectorIsNearlyEqual");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyEqual, A) == 0x000020, "Member 'FRigUnit_MathVectorIsNearlyEqual::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyEqual, B) == 0x00002C, "Member 'FRigUnit_MathVectorIsNearlyEqual::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyEqual, Tolerance) == 0x000038, "Member 'FRigUnit_MathVectorIsNearlyEqual::Tolerance' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyEqual, Result) == 0x00003C, "Member 'FRigUnit_MathVectorIsNearlyEqual::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorIsNearlyZero
// 0x0018 (0x0038 - 0x0020)
struct FRigUnit_MathVectorIsNearlyZero final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorIsNearlyZero) == 0x000008, "Wrong alignment on FRigUnit_MathVectorIsNearlyZero");
static_assert(sizeof(FRigUnit_MathVectorIsNearlyZero) == 0x000038, "Wrong size on FRigUnit_MathVectorIsNearlyZero");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyZero, Value) == 0x000020, "Member 'FRigUnit_MathVectorIsNearlyZero::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyZero, Tolerance) == 0x00002C, "Member 'FRigUnit_MathVectorIsNearlyZero::Tolerance' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorIsNearlyZero, Result) == 0x000030, "Member 'FRigUnit_MathVectorIsNearlyZero::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorNotEquals
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_MathVectorNotEquals final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_MathVectorNotEquals) == 0x000008, "Wrong alignment on FRigUnit_MathVectorNotEquals");
static_assert(sizeof(FRigUnit_MathVectorNotEquals) == 0x000040, "Wrong size on FRigUnit_MathVectorNotEquals");
static_assert(offsetof(FRigUnit_MathVectorNotEquals, A) == 0x000020, "Member 'FRigUnit_MathVectorNotEquals::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorNotEquals, B) == 0x00002C, "Member 'FRigUnit_MathVectorNotEquals::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorNotEquals, Result) == 0x000038, "Member 'FRigUnit_MathVectorNotEquals::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorLerp
// 0x0028 (0x0048 - 0x0020)
struct FRigUnit_MathVectorLerp final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorLerp) == 0x000008, "Wrong alignment on FRigUnit_MathVectorLerp");
static_assert(sizeof(FRigUnit_MathVectorLerp) == 0x000048, "Wrong size on FRigUnit_MathVectorLerp");
static_assert(offsetof(FRigUnit_MathVectorLerp, A) == 0x000020, "Member 'FRigUnit_MathVectorLerp::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLerp, B) == 0x00002C, "Member 'FRigUnit_MathVectorLerp::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLerp, T) == 0x000038, "Member 'FRigUnit_MathVectorLerp::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorLerp, Result) == 0x00003C, "Member 'FRigUnit_MathVectorLerp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorClamp
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MathVectorClamp final : public FRigUnit_MathVectorBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Minimum;                                           // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Maximum;                                           // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MathVectorClamp) == 0x000008, "Wrong alignment on FRigUnit_MathVectorClamp");
static_assert(sizeof(FRigUnit_MathVectorClamp) == 0x000050, "Wrong size on FRigUnit_MathVectorClamp");
static_assert(offsetof(FRigUnit_MathVectorClamp, Value) == 0x000020, "Member 'FRigUnit_MathVectorClamp::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClamp, Minimum) == 0x00002C, "Member 'FRigUnit_MathVectorClamp::Minimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClamp, Maximum) == 0x000038, "Member 'FRigUnit_MathVectorClamp::Maximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_MathVectorClamp, Result) == 0x000044, "Member 'FRigUnit_MathVectorClamp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MathVectorSign
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorSign final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorSign) == 0x000008, "Wrong alignment on FRigUnit_MathVectorSign");
static_assert(sizeof(FRigUnit_MathVectorSign) == 0x000038, "Wrong size on FRigUnit_MathVectorSign");

// ScriptStruct ControlRig.RigUnit_MathVectorRound
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorRound final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorRound) == 0x000008, "Wrong alignment on FRigUnit_MathVectorRound");
static_assert(sizeof(FRigUnit_MathVectorRound) == 0x000038, "Wrong size on FRigUnit_MathVectorRound");

// ScriptStruct ControlRig.RigUnit_MathVectorCeil
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorCeil final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorCeil) == 0x000008, "Wrong alignment on FRigUnit_MathVectorCeil");
static_assert(sizeof(FRigUnit_MathVectorCeil) == 0x000038, "Wrong size on FRigUnit_MathVectorCeil");

// ScriptStruct ControlRig.RigUnit_MathVectorFloor
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorFloor final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorFloor) == 0x000008, "Wrong alignment on FRigUnit_MathVectorFloor");
static_assert(sizeof(FRigUnit_MathVectorFloor) == 0x000038, "Wrong size on FRigUnit_MathVectorFloor");

// ScriptStruct ControlRig.RigUnit_MathVectorNegate
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_MathVectorNegate final : public FRigUnit_MathVectorUnaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorNegate) == 0x000008, "Wrong alignment on FRigUnit_MathVectorNegate");
static_assert(sizeof(FRigUnit_MathVectorNegate) == 0x000038, "Wrong size on FRigUnit_MathVectorNegate");

// ScriptStruct ControlRig.RigUnit_MathVectorMin
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_MathVectorMin final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorMin) == 0x000008, "Wrong alignment on FRigUnit_MathVectorMin");
static_assert(sizeof(FRigUnit_MathVectorMin) == 0x000048, "Wrong size on FRigUnit_MathVectorMin");

// ScriptStruct ControlRig.RigUnit_MathVectorDiv
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_MathVectorDiv final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorDiv) == 0x000008, "Wrong alignment on FRigUnit_MathVectorDiv");
static_assert(sizeof(FRigUnit_MathVectorDiv) == 0x000048, "Wrong size on FRigUnit_MathVectorDiv");

// ScriptStruct ControlRig.RigUnit_MathVectorSub
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_MathVectorSub final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorSub) == 0x000008, "Wrong alignment on FRigUnit_MathVectorSub");
static_assert(sizeof(FRigUnit_MathVectorSub) == 0x000048, "Wrong size on FRigUnit_MathVectorSub");

// ScriptStruct ControlRig.RigUnit_MathVectorAdd
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_MathVectorAdd final : public FRigUnit_MathVectorBinaryOp
{
};
static_assert(alignof(FRigUnit_MathVectorAdd) == 0x000008, "Wrong alignment on FRigUnit_MathVectorAdd");
static_assert(sizeof(FRigUnit_MathVectorAdd) == 0x000048, "Wrong size on FRigUnit_MathVectorAdd");

// ScriptStruct ControlRig.RigUnit_MergeHierarchy
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_MergeHierarchy final : public FRigUnit
{
public:
	struct FRigHierarchyRef                       TargetHierarchy;                                   // 0x0020(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FRigHierarchyRef                       SourceHierarchy;                                   // 0x0038(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MergeHierarchy) == 0x000008, "Wrong alignment on FRigUnit_MergeHierarchy");
static_assert(sizeof(FRigUnit_MergeHierarchy) == 0x000050, "Wrong size on FRigUnit_MergeHierarchy");
static_assert(offsetof(FRigUnit_MergeHierarchy, TargetHierarchy) == 0x000020, "Member 'FRigUnit_MergeHierarchy::TargetHierarchy' has a wrong offset!");
static_assert(offsetof(FRigUnit_MergeHierarchy, SourceHierarchy) == 0x000038, "Member 'FRigUnit_MergeHierarchy::SourceHierarchy' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ModifyBoneTransforms_PerBone
// 0x0040 (0x0040 - 0x0000)
struct FRigUnit_ModifyBoneTransforms_PerBone final
{
public:
	class FName                                   Bone;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ModifyBoneTransforms_PerBone) == 0x000010, "Wrong alignment on FRigUnit_ModifyBoneTransforms_PerBone");
static_assert(sizeof(FRigUnit_ModifyBoneTransforms_PerBone) == 0x000040, "Wrong size on FRigUnit_ModifyBoneTransforms_PerBone");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms_PerBone, Bone) == 0x000000, "Member 'FRigUnit_ModifyBoneTransforms_PerBone::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms_PerBone, Transform) == 0x000010, "Member 'FRigUnit_ModifyBoneTransforms_PerBone::Transform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_ModifyBoneTransforms
// 0x0030 (0x0068 - 0x0038)
struct FRigUnit_ModifyBoneTransforms final : public FRigUnit_HighlevelBaseMutable
{
public:
	TArray<struct FRigUnit_ModifyBoneTransforms_PerBone> BoneToModify;                                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightMinimum;                                     // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightMaximum;                                     // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigModifyBoneMode                     Mode;                                              // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 CachedBoneIndices;                                 // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ModifyBoneTransforms) == 0x000008, "Wrong alignment on FRigUnit_ModifyBoneTransforms");
static_assert(sizeof(FRigUnit_ModifyBoneTransforms) == 0x000068, "Wrong size on FRigUnit_ModifyBoneTransforms");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, BoneToModify) == 0x000038, "Member 'FRigUnit_ModifyBoneTransforms::BoneToModify' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, Weight) == 0x000048, "Member 'FRigUnit_ModifyBoneTransforms::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, WeightMinimum) == 0x00004C, "Member 'FRigUnit_ModifyBoneTransforms::WeightMinimum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, WeightMaximum) == 0x000050, "Member 'FRigUnit_ModifyBoneTransforms::WeightMaximum' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, Mode) == 0x000054, "Member 'FRigUnit_ModifyBoneTransforms::Mode' has a wrong offset!");
static_assert(offsetof(FRigUnit_ModifyBoneTransforms, CachedBoneIndices) == 0x000058, "Member 'FRigUnit_ModifyBoneTransforms::CachedBoneIndices' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_StartProfilingTimer
// 0x0000 (0x0038 - 0x0038)
struct FRigUnit_StartProfilingTimer final : public FRigUnit_DebugBaseMutable
{
};
static_assert(alignof(FRigUnit_StartProfilingTimer) == 0x000008, "Wrong alignment on FRigUnit_StartProfilingTimer");
static_assert(sizeof(FRigUnit_StartProfilingTimer) == 0x000038, "Wrong size on FRigUnit_StartProfilingTimer");

// ScriptStruct ControlRig.RigUnit_QuaternionToAngle
// 0x0030 (0x0050 - 0x0020)
struct FRigUnit_QuaternionToAngle final : public FRigUnit
{
public:
	struct FVector                                Axis;                                              // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Argument;                                          // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_QuaternionToAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionToAngle");
static_assert(sizeof(FRigUnit_QuaternionToAngle) == 0x000050, "Wrong size on FRigUnit_QuaternionToAngle");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Axis) == 0x000020, "Member 'FRigUnit_QuaternionToAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Argument) == 0x000030, "Member 'FRigUnit_QuaternionToAngle::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionToAngle, Angle) == 0x000040, "Member 'FRigUnit_QuaternionToAngle::Angle' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_QuaternionFromAxisAndAngle
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_QuaternionFromAxisAndAngle final : public FRigUnit
{
public:
	struct FVector                                Axis;                                              // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_QuaternionFromAxisAndAngle) == 0x000010, "Wrong alignment on FRigUnit_QuaternionFromAxisAndAngle");
static_assert(sizeof(FRigUnit_QuaternionFromAxisAndAngle) == 0x000040, "Wrong size on FRigUnit_QuaternionFromAxisAndAngle");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Axis) == 0x000020, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Angle) == 0x00002C, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Angle' has a wrong offset!");
static_assert(offsetof(FRigUnit_QuaternionFromAxisAndAngle, Result) == 0x000030, "Member 'FRigUnit_QuaternionFromAxisAndAngle::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_UnaryQuaternionOp
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_UnaryQuaternionOp : public FRigUnit
{
public:
	struct FQuat                                  Argument;                                          // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_UnaryQuaternionOp) == 0x000010, "Wrong alignment on FRigUnit_UnaryQuaternionOp");
static_assert(sizeof(FRigUnit_UnaryQuaternionOp) == 0x000040, "Wrong size on FRigUnit_UnaryQuaternionOp");
static_assert(offsetof(FRigUnit_UnaryQuaternionOp, Argument) == 0x000020, "Member 'FRigUnit_UnaryQuaternionOp::Argument' has a wrong offset!");
static_assert(offsetof(FRigUnit_UnaryQuaternionOp, Result) == 0x000030, "Member 'FRigUnit_UnaryQuaternionOp::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_InverseQuaterion
// 0x0000 (0x0040 - 0x0040)
struct FRigUnit_InverseQuaterion final : public FRigUnit_UnaryQuaternionOp
{
};
static_assert(alignof(FRigUnit_InverseQuaterion) == 0x000010, "Wrong alignment on FRigUnit_InverseQuaterion");
static_assert(sizeof(FRigUnit_InverseQuaterion) == 0x000040, "Wrong size on FRigUnit_InverseQuaterion");

// ScriptStruct ControlRig.RigUnit_MultiplyQuaternion
// 0x0000 (0x0050 - 0x0050)
struct FRigUnit_MultiplyQuaternion final : public FRigUnit_BinaryQuaternionOp
{
};
static_assert(alignof(FRigUnit_MultiplyQuaternion) == 0x000010, "Wrong alignment on FRigUnit_MultiplyQuaternion");
static_assert(sizeof(FRigUnit_MultiplyQuaternion) == 0x000050, "Wrong size on FRigUnit_MultiplyQuaternion");

// ScriptStruct ControlRig.RigUnit_SetBoneRotation
// 0x0028 (0x0060 - 0x0038)
struct FRigUnit_SetBoneRotation final : public FRigUnitMutable
{
public:
	class FName                                   Bone;                                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Rotation;                                          // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneGetterSetterMode                         Space;                                             // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedBoneIndex;                                   // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SetBoneRotation) == 0x000010, "Wrong alignment on FRigUnit_SetBoneRotation");
static_assert(sizeof(FRigUnit_SetBoneRotation) == 0x000060, "Wrong size on FRigUnit_SetBoneRotation");
static_assert(offsetof(FRigUnit_SetBoneRotation, Bone) == 0x000038, "Member 'FRigUnit_SetBoneRotation::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, Rotation) == 0x000040, "Member 'FRigUnit_SetBoneRotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, Space) == 0x000050, "Member 'FRigUnit_SetBoneRotation::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, bPropagateToChildren) == 0x000051, "Member 'FRigUnit_SetBoneRotation::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SetBoneRotation, CachedBoneIndex) == 0x000054, "Member 'FRigUnit_SetBoneRotation::CachedBoneIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_SpringIK
// 0x0158 (0x0190 - 0x0038)
struct FRigUnit_SpringIK final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   StartBone;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBone;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HierarchyStrength;                                 // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectorStrength;                                  // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectorRatio;                                     // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootStrength;                                      // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootRatio;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleVector;                                        // 0x0060(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipPolePlane;                                    // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigVectorKind                         PoleVectorKind;                                    // 0x006D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PoleVectorSpace;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x0078(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x0084(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLiveSimulation;                                   // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Iterations;                                        // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitLocalPosition;                               // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_SpringIK_DebugSettings        DebugSettings;                                     // 0x00A0(0x0050)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BoneIndices;                                       // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PoleVectorIndex;                                   // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Transforms;                                        // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCRSimPointContainer                   Simulation;                                        // 0x0118(0x0078)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SpringIK) == 0x000010, "Wrong alignment on FRigUnit_SpringIK");
static_assert(sizeof(FRigUnit_SpringIK) == 0x000190, "Wrong size on FRigUnit_SpringIK");
static_assert(offsetof(FRigUnit_SpringIK, StartBone) == 0x000038, "Member 'FRigUnit_SpringIK::StartBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, EndBone) == 0x000040, "Member 'FRigUnit_SpringIK::EndBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, HierarchyStrength) == 0x000048, "Member 'FRigUnit_SpringIK::HierarchyStrength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, EffectorStrength) == 0x00004C, "Member 'FRigUnit_SpringIK::EffectorStrength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, EffectorRatio) == 0x000050, "Member 'FRigUnit_SpringIK::EffectorRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, RootStrength) == 0x000054, "Member 'FRigUnit_SpringIK::RootStrength' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, RootRatio) == 0x000058, "Member 'FRigUnit_SpringIK::RootRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, Damping) == 0x00005C, "Member 'FRigUnit_SpringIK::Damping' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PoleVector) == 0x000060, "Member 'FRigUnit_SpringIK::PoleVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, bFlipPolePlane) == 0x00006C, "Member 'FRigUnit_SpringIK::bFlipPolePlane' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PoleVectorKind) == 0x00006D, "Member 'FRigUnit_SpringIK::PoleVectorKind' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PoleVectorSpace) == 0x000070, "Member 'FRigUnit_SpringIK::PoleVectorSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PrimaryAxis) == 0x000078, "Member 'FRigUnit_SpringIK::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, SecondaryAxis) == 0x000084, "Member 'FRigUnit_SpringIK::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, bLiveSimulation) == 0x000090, "Member 'FRigUnit_SpringIK::bLiveSimulation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, Iterations) == 0x000094, "Member 'FRigUnit_SpringIK::Iterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, bLimitLocalPosition) == 0x000098, "Member 'FRigUnit_SpringIK::bLimitLocalPosition' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, bPropagateToChildren) == 0x000099, "Member 'FRigUnit_SpringIK::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, DebugSettings) == 0x0000A0, "Member 'FRigUnit_SpringIK::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, BoneIndices) == 0x0000F0, "Member 'FRigUnit_SpringIK::BoneIndices' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, PoleVectorIndex) == 0x000100, "Member 'FRigUnit_SpringIK::PoleVectorIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, Transforms) == 0x000108, "Member 'FRigUnit_SpringIK::Transforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_SpringIK, Simulation) == 0x000118, "Member 'FRigUnit_SpringIK::Simulation' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Timeline
// 0x0010 (0x0030 - 0x0020)
struct FRigUnit_Timeline final : public FRigUnit_SimBase
{
public:
	float                                         Speed;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccumulatedValue;                                  // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Timeline) == 0x000008, "Wrong alignment on FRigUnit_Timeline");
static_assert(sizeof(FRigUnit_Timeline) == 0x000030, "Wrong size on FRigUnit_Timeline");
static_assert(offsetof(FRigUnit_Timeline, Speed) == 0x000020, "Member 'FRigUnit_Timeline::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_Timeline, Time) == 0x000024, "Member 'FRigUnit_Timeline::Time' has a wrong offset!");
static_assert(offsetof(FRigUnit_Timeline, AccumulatedValue) == 0x000028, "Member 'FRigUnit_Timeline::AccumulatedValue' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TimeOffsetTransform
// 0x00A0 (0x00C0 - 0x0020)
struct FRigUnit_TimeOffsetTransform final : public FRigUnit_SimBase
{
public:
	struct FTransform                             Value;                                             // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SecondsAgo;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRange;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0060(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Buffer;                                            // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 DeltaTimes;                                        // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TimeOffsetTransform) == 0x000010, "Wrong alignment on FRigUnit_TimeOffsetTransform");
static_assert(sizeof(FRigUnit_TimeOffsetTransform) == 0x0000C0, "Wrong size on FRigUnit_TimeOffsetTransform");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, Value) == 0x000020, "Member 'FRigUnit_TimeOffsetTransform::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, SecondsAgo) == 0x000050, "Member 'FRigUnit_TimeOffsetTransform::SecondsAgo' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, BufferSize) == 0x000054, "Member 'FRigUnit_TimeOffsetTransform::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, TimeRange) == 0x000058, "Member 'FRigUnit_TimeOffsetTransform::TimeRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, Result) == 0x000060, "Member 'FRigUnit_TimeOffsetTransform::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, Buffer) == 0x000090, "Member 'FRigUnit_TimeOffsetTransform::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, DeltaTimes) == 0x0000A0, "Member 'FRigUnit_TimeOffsetTransform::DeltaTimes' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetTransform, LastInsertIndex) == 0x0000B0, "Member 'FRigUnit_TimeOffsetTransform::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TimeOffsetVector
// 0x0050 (0x0070 - 0x0020)
struct FRigUnit_TimeOffsetVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Value;                                             // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsAgo;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRange;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Buffer;                                            // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 DeltaTimes;                                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TimeOffsetVector) == 0x000008, "Wrong alignment on FRigUnit_TimeOffsetVector");
static_assert(sizeof(FRigUnit_TimeOffsetVector) == 0x000070, "Wrong size on FRigUnit_TimeOffsetVector");
static_assert(offsetof(FRigUnit_TimeOffsetVector, Value) == 0x000020, "Member 'FRigUnit_TimeOffsetVector::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, SecondsAgo) == 0x00002C, "Member 'FRigUnit_TimeOffsetVector::SecondsAgo' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, BufferSize) == 0x000030, "Member 'FRigUnit_TimeOffsetVector::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, TimeRange) == 0x000034, "Member 'FRigUnit_TimeOffsetVector::TimeRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, Result) == 0x000038, "Member 'FRigUnit_TimeOffsetVector::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, Buffer) == 0x000048, "Member 'FRigUnit_TimeOffsetVector::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, DeltaTimes) == 0x000058, "Member 'FRigUnit_TimeOffsetVector::DeltaTimes' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetVector, LastInsertIndex) == 0x000068, "Member 'FRigUnit_TimeOffsetVector::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TimeOffsetFloat
// 0x0040 (0x0060 - 0x0020)
struct FRigUnit_TimeOffsetFloat final : public FRigUnit_SimBase
{
public:
	float                                         Value;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsAgo;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BufferSize;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRange;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Buffer;                                            // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 DeltaTimes;                                        // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LastInsertIndex;                                   // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TimeOffsetFloat) == 0x000008, "Wrong alignment on FRigUnit_TimeOffsetFloat");
static_assert(sizeof(FRigUnit_TimeOffsetFloat) == 0x000060, "Wrong size on FRigUnit_TimeOffsetFloat");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, Value) == 0x000020, "Member 'FRigUnit_TimeOffsetFloat::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, SecondsAgo) == 0x000024, "Member 'FRigUnit_TimeOffsetFloat::SecondsAgo' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, BufferSize) == 0x000028, "Member 'FRigUnit_TimeOffsetFloat::BufferSize' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, TimeRange) == 0x00002C, "Member 'FRigUnit_TimeOffsetFloat::TimeRange' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, Result) == 0x000030, "Member 'FRigUnit_TimeOffsetFloat::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, Buffer) == 0x000038, "Member 'FRigUnit_TimeOffsetFloat::Buffer' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, DeltaTimes) == 0x000048, "Member 'FRigUnit_TimeOffsetFloat::DeltaTimes' has a wrong offset!");
static_assert(offsetof(FRigUnit_TimeOffsetFloat, LastInsertIndex) == 0x000058, "Member 'FRigUnit_TimeOffsetFloat::LastInsertIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_MultiplyTransform
// 0x0000 (0x00B0 - 0x00B0)
struct FRigUnit_MultiplyTransform final : public FRigUnit_BinaryTransformOp
{
};
static_assert(alignof(FRigUnit_MultiplyTransform) == 0x000010, "Wrong alignment on FRigUnit_MultiplyTransform");
static_assert(sizeof(FRigUnit_MultiplyTransform) == 0x0000B0, "Wrong size on FRigUnit_MultiplyTransform");

// ScriptStruct ControlRig.RigUnit_TransformConstraint
// 0x00C8 (0x0100 - 0x0038)
struct FRigUnit_TransformConstraint final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   Bone;                                              // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransformSpaceMode                           BaseTransformSpace;                                // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0050(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   BaseBone;                                          // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConstraintTarget>              Targets;                                           // 0x0088(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x68];                                      // 0x0098(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TransformConstraint) == 0x000010, "Wrong alignment on FRigUnit_TransformConstraint");
static_assert(sizeof(FRigUnit_TransformConstraint) == 0x000100, "Wrong size on FRigUnit_TransformConstraint");
static_assert(offsetof(FRigUnit_TransformConstraint, Bone) == 0x000038, "Member 'FRigUnit_TransformConstraint::Bone' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseTransformSpace) == 0x000040, "Member 'FRigUnit_TransformConstraint::BaseTransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseTransform) == 0x000050, "Member 'FRigUnit_TransformConstraint::BaseTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, BaseBone) == 0x000080, "Member 'FRigUnit_TransformConstraint::BaseBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_TransformConstraint, Targets) == 0x000088, "Member 'FRigUnit_TransformConstraint::Targets' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKFK
// 0x01B8 (0x01F0 - 0x0038)
struct FRigUnit_TwoBoneIKFK final : public FRigUnitMutable
{
public:
	class FName                                   StartJoint;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndJoint;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePoleTarget;                                    // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PoleTarget;                                        // 0x004C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spin;                                              // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EndEffector;                                       // 0x0060(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IKBlend;                                           // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartJointFKTransform;                             // 0x00A0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             MidJointFKTransform;                               // 0x00D0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             EndJointFKTransform;                               // 0x0100(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0xC0];                                     // 0x0130(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_TwoBoneIKFK) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKFK");
static_assert(sizeof(FRigUnit_TwoBoneIKFK) == 0x0001F0, "Wrong size on FRigUnit_TwoBoneIKFK");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, StartJoint) == 0x000038, "Member 'FRigUnit_TwoBoneIKFK::StartJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndJoint) == 0x000040, "Member 'FRigUnit_TwoBoneIKFK::EndJoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, bUsePoleTarget) == 0x000048, "Member 'FRigUnit_TwoBoneIKFK::bUsePoleTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, PoleTarget) == 0x00004C, "Member 'FRigUnit_TwoBoneIKFK::PoleTarget' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, Spin) == 0x000058, "Member 'FRigUnit_TwoBoneIKFK::Spin' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndEffector) == 0x000060, "Member 'FRigUnit_TwoBoneIKFK::EndEffector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, IKBlend) == 0x000090, "Member 'FRigUnit_TwoBoneIKFK::IKBlend' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, StartJointFKTransform) == 0x0000A0, "Member 'FRigUnit_TwoBoneIKFK::StartJointFKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, MidJointFKTransform) == 0x0000D0, "Member 'FRigUnit_TwoBoneIKFK::MidJointFKTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKFK, EndJointFKTransform) == 0x000100, "Member 'FRigUnit_TwoBoneIKFK::EndJointFKTransform' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKSimple_DebugSettings
// 0x0040 (0x0040 - 0x0000)
struct FRigUnit_TwoBoneIKSimple_DebugSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldOffset;                                       // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwoBoneIKSimple_DebugSettings) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKSimple_DebugSettings");
static_assert(sizeof(FRigUnit_TwoBoneIKSimple_DebugSettings) == 0x000040, "Wrong size on FRigUnit_TwoBoneIKSimple_DebugSettings");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple_DebugSettings, bEnabled) == 0x000000, "Member 'FRigUnit_TwoBoneIKSimple_DebugSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple_DebugSettings, Scale) == 0x000004, "Member 'FRigUnit_TwoBoneIKSimple_DebugSettings::Scale' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple_DebugSettings, WorldOffset) == 0x000010, "Member 'FRigUnit_TwoBoneIKSimple_DebugSettings::WorldOffset' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_TwoBoneIKSimple
// 0x00E8 (0x0120 - 0x0038)
struct FRigUnit_TwoBoneIKSimple final : public FRigUnit_HighlevelBaseMutable
{
public:
	class FName                                   BoneA;                                             // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneB;                                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectorBone;                                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Effector;                                          // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PrimaryAxis;                                       // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondaryAxis;                                     // 0x008C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoleVector;                                        // 0x0098(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigVectorKind                         PoleVectorKind;                                    // 0x00A4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PoleVectorSpace;                                   // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStretch;                                    // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StretchStartRatio;                                 // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StretchMaximumRatio;                               // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneALength;                                       // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneBLength;                                       // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_TwoBoneIKSimple_DebugSettings DebugSettings;                                     // 0x00D0(0x0040)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BoneAIndex;                                        // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneBIndex;                                        // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectorBoneIndex;                                 // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoleVectorSpaceIndex;                              // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_TwoBoneIKSimple) == 0x000010, "Wrong alignment on FRigUnit_TwoBoneIKSimple");
static_assert(sizeof(FRigUnit_TwoBoneIKSimple) == 0x000120, "Wrong size on FRigUnit_TwoBoneIKSimple");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneA) == 0x000038, "Member 'FRigUnit_TwoBoneIKSimple::BoneA' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneB) == 0x000040, "Member 'FRigUnit_TwoBoneIKSimple::BoneB' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, EffectorBone) == 0x000048, "Member 'FRigUnit_TwoBoneIKSimple::EffectorBone' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, Effector) == 0x000050, "Member 'FRigUnit_TwoBoneIKSimple::Effector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PrimaryAxis) == 0x000080, "Member 'FRigUnit_TwoBoneIKSimple::PrimaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, SecondaryAxis) == 0x00008C, "Member 'FRigUnit_TwoBoneIKSimple::SecondaryAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PoleVector) == 0x000098, "Member 'FRigUnit_TwoBoneIKSimple::PoleVector' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PoleVectorKind) == 0x0000A4, "Member 'FRigUnit_TwoBoneIKSimple::PoleVectorKind' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PoleVectorSpace) == 0x0000A8, "Member 'FRigUnit_TwoBoneIKSimple::PoleVectorSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, bEnableStretch) == 0x0000B0, "Member 'FRigUnit_TwoBoneIKSimple::bEnableStretch' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, StretchStartRatio) == 0x0000B4, "Member 'FRigUnit_TwoBoneIKSimple::StretchStartRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, StretchMaximumRatio) == 0x0000B8, "Member 'FRigUnit_TwoBoneIKSimple::StretchMaximumRatio' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, Weight) == 0x0000BC, "Member 'FRigUnit_TwoBoneIKSimple::Weight' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneALength) == 0x0000C0, "Member 'FRigUnit_TwoBoneIKSimple::BoneALength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneBLength) == 0x0000C4, "Member 'FRigUnit_TwoBoneIKSimple::BoneBLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, bPropagateToChildren) == 0x0000C8, "Member 'FRigUnit_TwoBoneIKSimple::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, DebugSettings) == 0x0000D0, "Member 'FRigUnit_TwoBoneIKSimple::DebugSettings' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneAIndex) == 0x000110, "Member 'FRigUnit_TwoBoneIKSimple::BoneAIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, BoneBIndex) == 0x000114, "Member 'FRigUnit_TwoBoneIKSimple::BoneBIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, EffectorBoneIndex) == 0x000118, "Member 'FRigUnit_TwoBoneIKSimple::EffectorBoneIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_TwoBoneIKSimple, PoleVectorSpaceIndex) == 0x00011C, "Member 'FRigUnit_TwoBoneIKSimple::PoleVectorSpaceIndex' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Distance_VectorVector
// 0x0020 (0x0040 - 0x0020)
struct FRigUnit_Distance_VectorVector final : public FRigUnit
{
public:
	struct FVector                                Argument0;                                         // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Argument1;                                         // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_Distance_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Distance_VectorVector");
static_assert(sizeof(FRigUnit_Distance_VectorVector) == 0x000040, "Wrong size on FRigUnit_Distance_VectorVector");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Argument0) == 0x000020, "Member 'FRigUnit_Distance_VectorVector::Argument0' has a wrong offset!");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Argument1) == 0x00002C, "Member 'FRigUnit_Distance_VectorVector::Argument1' has a wrong offset!");
static_assert(offsetof(FRigUnit_Distance_VectorVector, Result) == 0x000038, "Member 'FRigUnit_Distance_VectorVector::Result' has a wrong offset!");

// ScriptStruct ControlRig.RigUnit_Subtract_VectorVector
// 0x0000 (0x0048 - 0x0048)
struct FRigUnit_Subtract_VectorVector final : public FRigUnit_BinaryVectorOp
{
};
static_assert(alignof(FRigUnit_Subtract_VectorVector) == 0x000008, "Wrong alignment on FRigUnit_Subtract_VectorVector");
static_assert(sizeof(FRigUnit_Subtract_VectorVector) == 0x000048, "Wrong size on FRigUnit_Subtract_VectorVector");

// ScriptStruct ControlRig.RigUnit_VerletIntegrateVector
// 0x0068 (0x0088 - 0x0020)
struct FRigUnit_VerletIntegrateVector final : public FRigUnit_SimBase
{
public:
	struct FVector                                Target;                                            // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damp;                                              // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration;                                      // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCRSimPoint                            Point;                                             // 0x005C(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_VerletIntegrateVector) == 0x000008, "Wrong alignment on FRigUnit_VerletIntegrateVector");
static_assert(sizeof(FRigUnit_VerletIntegrateVector) == 0x000088, "Wrong size on FRigUnit_VerletIntegrateVector");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Target) == 0x000020, "Member 'FRigUnit_VerletIntegrateVector::Target' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Strength) == 0x00002C, "Member 'FRigUnit_VerletIntegrateVector::Strength' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Damp) == 0x000030, "Member 'FRigUnit_VerletIntegrateVector::Damp' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Blend) == 0x000034, "Member 'FRigUnit_VerletIntegrateVector::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Position) == 0x000038, "Member 'FRigUnit_VerletIntegrateVector::Position' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Velocity) == 0x000044, "Member 'FRigUnit_VerletIntegrateVector::Velocity' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Acceleration) == 0x000050, "Member 'FRigUnit_VerletIntegrateVector::Acceleration' has a wrong offset!");
static_assert(offsetof(FRigUnit_VerletIntegrateVector, Point) == 0x00005C, "Member 'FRigUnit_VerletIntegrateVector::Point' has a wrong offset!");

}

